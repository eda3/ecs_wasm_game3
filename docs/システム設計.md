# システム設計

ECSアーキテクチャにおけるシステムは、ゲームのロジックを実装する中心的な要素です。各システムは特定のタスクに焦点を当て、関連するコンポーネントを持つエンティティに対して処理を行います。

## システム設計原則

1. **単一責任の原則** - 各システムは明確に定義された一つの責任を持つ
2. **データ指向設計** - データ（コンポーネント）の流れに注目した設計
3. **疎結合** - システム間の依存関係を最小限に抑える
4. **再利用性** - 汎用的なシステムを設計し、異なるコンテキストで再利用可能に
5. **テスト容易性** - システムの動作を個別にテストできるような設計

## コアシステム

### 1. レンダリングシステム

```rust
pub struct RenderingSystem {
    canvas_context: CanvasRenderingContext2d,
}

impl System for RenderingSystem {
    fn run(&mut self, world: &mut World, _delta_time: f32) {
        // キャンバスをクリア
        self.canvas_context.clear_rect(
            0.0, 0.0,
            self.canvas_context.canvas().unwrap().width() as f64,
            self.canvas_context.canvas().unwrap().height() as f64,
        );
        
        // カメラ設定を取得
        let camera = world.get_resource::<CameraResource>().unwrap();
        
        // 描画エンティティのクエリ（Position + Spriteを持つエンティティ）
        let render_query = world.query::<(&Position, &Sprite)>();
        
        // 描画順にソート（Z-orderなど）
        // ...ソートロジック...
        
        // 各エンティティを描画
        for (entity, (position, sprite)) in render_query.iter_with_components() {
            // スプライトのレンダリング
            self.canvas_context.save();
            self.canvas_context.translate(
                (position.x - camera.position.x) as f64,
                (position.y - camera.position.y) as f64,
            );
            
            // スプライト描画ロジック
            // ...
            
            self.canvas_context.restore();
        }
        
        // UIレイヤーの描画
        self.render_ui(world);
    }
}

impl RenderingSystem {
    pub fn new(canvas_context: CanvasRenderingContext2d) -> Self {
        Self { canvas_context }
    }
    
    fn render_ui(&self, world: &World) {
        // UIコンポーネントの描画
        // ...
    }
}
```

### 2. 物理/衝突システム

物理システムは以下の主要コンポーネントで構成されています：

#### 2.1 衝突検出システム

```rust
pub mod collision {
    /// 衝突形状の定義
    pub enum CollisionShape {
        /// 円形
        Circle {
            /// 半径
            radius: f64,
        },
        /// AABB（軸並行境界ボックス）
        AABB {
            /// 幅
            width: f64,
            /// 高さ
            height: f64,
        },
        /// 多角形
        Polygon {
            /// 頂点座標のリスト（ローカル座標）
            vertices: Vec<(f64, f64)>,
        },
    }

    /// 衝突情報
    pub struct Collision {
        /// 衝突点の位置
        pub position: (f64, f64),
        /// 衝突の法線ベクトル（衝突面の垂直方向）
        pub normal: (f64, f64),
        /// 貫通深度
        pub penetration: f64,
    }

    /// 2つのエンティティ間の衝突を検出
    pub fn detect_collision(entity_a: &PhysicsEntity, entity_b: &PhysicsEntity) -> Option<Collision> {
        // 形状タイプに基づいて適切な検出関数を呼び出し
        match (&entity_a.shape, &entity_b.shape) {
            (CollisionShape::Circle { radius: radius_a }, CollisionShape::Circle { radius: radius_b }) => {
                detect_circle_circle(entity_a.position, *radius_a, entity_b.position, *radius_b)
            },
            (CollisionShape::AABB { width: width_a, height: height_a }, 
             CollisionShape::AABB { width: width_b, height: height_b }) => {
                detect_aabb_aabb(entity_a.position, *width_a, *height_a, 
                                entity_b.position, *width_b, *height_b)
            },
            // その他の組み合わせは省略...
        }
    }
}
```

#### 2.2 物理演算システム

```rust
pub mod dynamics {
    /// 衝突解決器
    pub struct CollisionResolver {
        /// 位置補正の割合（0-1）
        position_correction_rate: f64,
        /// イテレーション回数
        iterations: usize,
    }

    impl CollisionResolver {
        /// 衝突を解決
        pub fn resolve_collision(
            &self,
            entity_a: &mut PhysicsEntity,
            entity_b: &mut PhysicsEntity,
            collision: &Collision,
        ) {
            // 静的物体の場合は処理を分岐
            if entity_a.is_static && entity_b.is_static {
                return;
            } else if entity_a.is_static {
                self.resolve_collision_one_sided(entity_b, entity_a, collision, true);
                return;
            } else if entity_b.is_static {
                self.resolve_collision_one_sided(entity_a, entity_b, collision, false);
                return;
            }
            
            // 衝撃計算と速度更新
            // ...省略...
            
            // 摩擦力の適用
            self.apply_friction(entity_a, entity_b, collision, inverse_mass_a, inverse_mass_b, j);
            
            // 位置補正（めり込み解消）
            self.correct_position(entity_a, entity_b, collision);
        }
    }

    /// 積分器（運動方程式の数値積分）
    pub struct Integrator {
        /// 最大速度
        max_velocity: f64,
        /// 最大角速度
        max_angular_velocity: f64,
    }

    impl Integrator {
        /// 物理エンティティを更新（オイラー法）
        pub fn integrate(&self, entity: &mut PhysicsEntity, dt: f64, gravity: (f64, f64), damping: f64) {
            if entity.is_static {
                return;
            }
            
            // 加速度、速度、位置の更新
            // ...省略...
            
            // 角度の更新
            // ...省略...
        }
    }

    /// 力の生成器
    pub struct ForceGenerator {
        /// 重力定数
        gravity: (f64, f64),
    }

    impl ForceGenerator {
        /// 力を適用
        pub fn apply_force(&self, entity: &mut PhysicsEntity, force: (f64, f64)) {
            // F = ma より a = F/m
            // ...省略...
        }

        /// トルクを適用
        pub fn apply_torque(&self, entity: &mut PhysicsEntity, torque: f64) {
            // ...省略...
        }
        
        /// 特定の位置に力を適用（トルクも生成）
        pub fn apply_force_at_point(
            &self,
            entity: &mut PhysicsEntity,
            force: (f64, f64),
            application_point: (f64, f64),
        ) {
            // ...省略...
        }
        
        /// ばね力を適用
        pub fn apply_spring_force(
            &self,
            entity: &mut PhysicsEntity,
            anchor_point: (f64, f64),
            rest_length: f64,
            spring_constant: f64,
        ) {
            // ...省略...
        }
        
        /// 抗力（空気抵抗など）を適用
        pub fn apply_drag_force(
            &self,
            entity: &mut PhysicsEntity,
            drag_coefficient: f64,
        ) {
            // ...省略...
        }
    }
}
```

#### 2.3 物理最適化システム（予定）

```rust
pub mod optimization {
    /// 空間分割グリッド
    pub struct SpatialGrid {
        /// セルのサイズ
        cell_size: f64,
        /// グリッドのセル（キー: セルID, 値: エンティティIDのリスト）
        cells: HashMap<(i32, i32), Vec<u32>>,
    }

    /// 衝突フィルタリング
    pub struct CollisionFilter {
        /// 衝突フィルターのマスク（キー: エンティティID, 値: フィルターマスク）
        masks: HashMap<u32, u32>,
        /// 衝突フィルターのカテゴリ（キー: エンティティID, 値: カテゴリ）
        categories: HashMap<u32, u32>,
    }

    /// 物理ステップ最適化
    pub struct PhysicsStep {
        /// 累積時間
        accumulated_time: f64,
        /// 固定時間ステップ
        fixed_time_step: f64,
        /// 最大ステップ数
        max_steps_per_update: usize,
    }
}
```

### 3. 入力処理システム

```rust
pub struct InputSystem {
    // マウスの前回位置
    last_mouse_position: (f32, f32),
    // タッチの前回位置
    last_touch_positions: HashMap<i32, (f32, f32)>,
    // ジェスチャー検出器
    gesture_detector: GestureDetector,
}

impl System for InputSystem {
    fn run(&mut self, world: &mut World, delta_time: f32) {
        // 入力リソースを取得
        let mut input = world.get_resource_mut::<InputResource>().unwrap();
        
        // 前のフレームのキー状態を保存
        input.previous_keyboard = input.keyboard.clone();
        input.previous_mouse_buttons = input.mouse_buttons.clone();
        
        // キー入力の処理
        self.process_keyboard_input(&mut input);
        
        // マウス入力の処理
        self.process_mouse_input(&mut input, delta_time);
        
        // タッチ入力の処理
        self.process_touch_input(&mut input, delta_time);
        
        // 入力を処理するエンティティを取得（PlayerControlledコンポーネントを持つもの）
        for entity in world.query::<&PlayerControlled>().iter() {
            let mut velocity = world.get_component_mut::<Velocity>(entity).unwrap();
            
            // キーボード入力による移動処理
            velocity.x = 0.0;  // リセット
            
            if input.is_key_pressed(KeyCodes::KEY_A) || input.is_key_pressed(KeyCodes::ARROW_LEFT) {
                velocity.x -= 5.0;
            }
            if input.is_key_pressed(KeyCodes::KEY_D) || input.is_key_pressed(KeyCodes::ARROW_RIGHT) {
                velocity.x += 5.0;
            }
            
            // ジャンプ処理
            if input.is_key_just_pressed(KeyCodes::KEY_W) || 
               input.is_key_just_pressed(KeyCodes::KEY_SPACE) || 
               input.is_key_just_pressed(KeyCodes::ARROW_UP) {
                // ジャンプは地上にいる場合のみ
                if let Some(grounded) = world.get_component::<Grounded>(entity) {
                    if grounded.is_grounded {
                        velocity.y = -10.0;  // 上向きに力を加える
                    }
                }
            }
            
            // ジェスチャー入力の処理
            if let Some(gesture) = &input.current_gesture {
                match gesture {
                    Gesture::Swipe { direction, velocity, .. } => {
                        // スワイプジェスチャーでの移動
                        if direction.x.abs() > direction.y.abs() {
                            velocity.x = direction.x * velocity * 0.5;
                        }
                    },
                    Gesture::Tap { .. } => {
                        // タップでのジャンプ
                        if let Some(grounded) = world.get_component::<Grounded>(entity) {
                            if grounded.is_grounded {
                                velocity.y = -10.0;
                            }
                        }
                    },
                    // その他のジェスチャー処理...
                    _ => {}
                }
            }
        }
    }
}

impl InputSystem {
    pub fn new() -> Self {
        Self {
            last_mouse_position: (0.0, 0.0),
            last_touch_positions: HashMap::new(),
            gesture_detector: GestureDetector::new(),
        }
    }
    
    fn process_keyboard_input(&self, input: &mut InputResource) {
        // JavaScriptからキー状態を取得する処理
        // ...
    }
    
    fn process_mouse_input(&mut self, input: &mut InputResource, delta_time: f32) {
        // JavaScriptからマウス状態を取得する処理
        // ...
        
        // マウス移動の計算
        let current_position = (input.mouse_x, input.mouse_y);
        input.mouse_delta_x = current_position.0 - self.last_mouse_position.0;
        input.mouse_delta_y = current_position.1 - self.last_mouse_position.1;
        self.last_mouse_position = current_position;
    }
    
    fn process_touch_input(&mut self, input: &mut InputResource, delta_time: f32) {
        // タッチ入力の処理
        for (id, touch) in &input.touches {
            // 新しいタッチの場合
            if !self.last_touch_positions.contains_key(id) {
                self.last_touch_positions.insert(*id, (touch.x, touch.y));
                continue;
            }
            
            // タッチの移動を計算
            let last_pos = self.last_touch_positions[id];
            let delta = (touch.x - last_pos.0, touch.y - last_pos.1);
            
            // ジェスチャー検出器にタッチイベントを送信
            self.gesture_detector.process_touch(
                TouchEvent {
                    id: *id,
                    x: touch.x,
                    y: touch.y,
                    phase: TouchPhase::Moved,
                    timestamp: web_sys::window().unwrap().performance().unwrap().now(),
                    delta_x: delta.0,
                    delta_y: delta.1,
                }
            );
            
            // 現在位置を保存
            self.last_touch_positions.insert(*id, (touch.x, touch.y));
        }
        
        // 終了したタッチを処理
        let ended_touches: Vec<i32> = self.last_touch_positions.keys()
            .filter(|id| !input.touches.contains_key(*id))
            .copied()
            .collect();
            
        for id in ended_touches {
            let last_pos = self.last_touch_positions.remove(&id).unwrap();
            
            // ジェスチャー検出器にタッチ終了イベントを送信
            self.gesture_detector.process_touch(
                TouchEvent {
                    id,
                    x: last_pos.0,
                    y: last_pos.1,
                    phase: TouchPhase::Ended,
                    timestamp: web_sys::window().unwrap().performance().unwrap().now(),
                    delta_x: 0.0,
                    delta_y: 0.0,
                }
            );
        }
        
        // ジェスチャーの更新と検出
        if let Some(gesture) = self.gesture_detector.update(delta_time) {
            input.current_gesture = Some(gesture);
        } else {
            input.current_gesture = None;
        }
    }
}
```

#### 3.1 入力リソース

```rust
pub struct InputResource {
    // キーボード状態（キーコード → 押されているか）
    pub keyboard: HashMap<u32, bool>,
    // 前フレームのキーボード状態
    pub previous_keyboard: HashMap<u32, bool>,
    
    // マウス状態
    pub mouse_x: f32,
    pub mouse_y: f32,
    pub mouse_delta_x: f32,
    pub mouse_delta_y: f32,
    pub mouse_wheel_delta: f32,
    pub mouse_buttons: HashMap<u32, bool>,
    pub previous_mouse_buttons: HashMap<u32, bool>,
    
    // タッチ状態
    pub touches: HashMap<i32, Touch>,
    pub current_gesture: Option<Gesture>,
}

impl InputResource {
    pub fn new() -> Self {
        Self {
            keyboard: HashMap::new(),
            previous_keyboard: HashMap::new(),
            mouse_x: 0.0,
            mouse_y: 0.0,
            mouse_delta_x: 0.0,
            mouse_delta_y: 0.0,
            mouse_wheel_delta: 0.0,
            mouse_buttons: HashMap::new(),
            previous_mouse_buttons: HashMap::new(),
            touches: HashMap::new(),
            current_gesture: None,
        }
    }
    
    // キーが現在押されているか
    pub fn is_key_pressed(&self, key_code: u32) -> bool {
        *self.keyboard.get(&key_code).unwrap_or(&false)
    }
    
    // キーが今フレームで押されたか
    pub fn is_key_just_pressed(&self, key_code: u32) -> bool {
        *self.keyboard.get(&key_code).unwrap_or(&false) && 
        !*self.previous_keyboard.get(&key_code).unwrap_or(&false)
    }
    
    // キーが今フレームで離されたか
    pub fn is_key_just_released(&self, key_code: u32) -> bool {
        !*self.keyboard.get(&key_code).unwrap_or(&false) && 
        *self.previous_keyboard.get(&key_code).unwrap_or(&false)
    }
    
    // マウスボタンが現在押されているか
    pub fn is_mouse_button_pressed(&self, button: u32) -> bool {
        *self.mouse_buttons.get(&button).unwrap_or(&false)
    }
    
    // マウスボタンが今フレームで押されたか
    pub fn is_mouse_button_just_pressed(&self, button: u32) -> bool {
        *self.mouse_buttons.get(&button).unwrap_or(&false) && 
        !*self.previous_mouse_buttons.get(&button).unwrap_or(&false)
    }
    
    // マウスボタンが今フレームで離されたか
    pub fn is_mouse_button_just_released(&self, button: u32) -> bool {
        !*self.mouse_buttons.get(&button).unwrap_or(&false) && 
        *self.previous_mouse_buttons.get(&button).unwrap_or(&false)
    }
}
```

#### 3.2 キーコード定義

```rust
pub mod key_codes {
    // マウスボタン
    pub const MOUSE_LEFT: u32 = 0;
    pub const MOUSE_RIGHT: u32 = 2;
    pub const MOUSE_MIDDLE: u32 = 1;
    
    // キーボードキー - アルファベット
    pub const KEY_A: u32 = 65;
    pub const KEY_B: u32 = 66;
    pub const KEY_C: u32 = 67;
    pub const KEY_D: u32 = 68;
    pub const KEY_E: u32 = 69;
    pub const KEY_F: u32 = 70;
    pub const KEY_G: u32 = 71;
    pub const KEY_H: u32 = 72;
    pub const KEY_I: u32 = 73;
    pub const KEY_J: u32 = 74;
    pub const KEY_K: u32 = 75;
    pub const KEY_L: u32 = 76;
    pub const KEY_M: u32 = 77;
    pub const KEY_N: u32 = 78;
    pub const KEY_O: u32 = 79;
    pub const KEY_P: u32 = 80;
    pub const KEY_Q: u32 = 81;
    pub const KEY_R: u32 = 82;
    pub const KEY_S: u32 = 83;
    pub const KEY_T: u32 = 84;
    pub const KEY_U: u32 = 85;
    pub const KEY_V: u32 = 86;
    pub const KEY_W: u32 = 87;
    pub const KEY_X: u32 = 88;
    pub const KEY_Y: u32 = 89;
    pub const KEY_Z: u32 = 90;
    
    // キーボードキー - 数字
    pub const KEY_0: u32 = 48;
    pub const KEY_1: u32 = 49;
    pub const KEY_2: u32 = 50;
    pub const KEY_3: u32 = 51;
    pub const KEY_4: u32 = 52;
    pub const KEY_5: u32 = 53;
    pub const KEY_6: u32 = 54;
    pub const KEY_7: u32 = 55;
    pub const KEY_8: u32 = 56;
    pub const KEY_9: u32 = 57;
    
    // キーボードキー - 特殊キー
    pub const KEY_SPACE: u32 = 32;
    pub const KEY_ENTER: u32 = 13;
    pub const KEY_ESCAPE: u32 = 27;
    pub const KEY_SHIFT: u32 = 16;
    pub const KEY_CTRL: u32 = 17;
    pub const KEY_ALT: u32 = 18;
    pub const KEY_TAB: u32 = 9;
    pub const KEY_BACKSPACE: u32 = 8;
    
    // キーボードキー - 矢印キー
    pub const ARROW_UP: u32 = 38;
    pub const ARROW_DOWN: u32 = 40;
    pub const ARROW_LEFT: u32 = 37;
    pub const ARROW_RIGHT: u32 = 39;
    
    // キーボードキー - ファンクションキー
    pub const KEY_F1: u32 = 112;
    pub const KEY_F2: u32 = 113;
    pub const KEY_F3: u32 = 114;
    pub const KEY_F4: u32 = 115;
    pub const KEY_F5: u32 = 116;
    pub const KEY_F6: u32 = 117;
    pub const KEY_F7: u32 = 118;
    pub const KEY_F8: u32 = 119;
    pub const KEY_F9: u32 = 120;
    pub const KEY_F10: u32 = 121;
    pub const KEY_F11: u32 = 122;
    pub const KEY_F12: u32 = 123;
}
```

#### 3.3 ジェスチャー検出

```rust
pub mod gesture {
    // タッチ位相
    pub enum TouchPhase {
        Began,
        Moved,
        Ended,
        Cancelled,
    }
    
    // タッチイベント
    pub struct TouchEvent {
        pub id: i32,
        pub x: f32,
        pub y: f32,
        pub phase: TouchPhase,
        pub timestamp: f64,
        pub delta_x: f32,
        pub delta_y: f32,
    }
    
    // タッチポイント
    pub struct Touch {
        pub id: i32,
        pub x: f32,
        pub y: f32,
        pub start_x: f32,
        pub start_y: f32,
        pub start_time: f64,
    }
    
    // ジェスチャータイプ
    pub enum Gesture {
        Tap {
            position: (f32, f32),
            time: f64,
        },
        DoubleTap {
            position: (f32, f32),
            time: f64,
        },
        LongPress {
            position: (f32, f32),
            duration: f64,
        },
        Swipe {
            start_position: (f32, f32),
            end_position: (f32, f32),
            direction: (f32, f32),
            velocity: f32,
            time: f64,
        },
        Pinch {
            center: (f32, f32),
            scale: f32,
            velocity: f32,
        },
        Rotate {
            center: (f32, f32),
            angle: f32,
            velocity: f32,
        },
    }
    
    // ジェスチャー検出器
    pub struct GestureDetector {
        // アクティブなタッチ
        active_touches: HashMap<i32, Touch>,
        // タップ履歴（ダブルタップ検出用）
        tap_history: Vec<(f32, f32, f64)>,
        // 長押し検出用タイマー
        long_press_timer: Option<(i32, f32, f32, f64)>,
        // 設定
        double_tap_time_threshold: f64,
        long_press_time_threshold: f64,
        tap_distance_threshold: f32,
        swipe_velocity_threshold: f32,
    }
    
    impl GestureDetector {
        pub fn new() -> Self {
            Self {
                active_touches: HashMap::new(),
                tap_history: Vec::new(),
                long_press_timer: None,
                double_tap_time_threshold: 300.0,  // ミリ秒
                long_press_time_threshold: 500.0,  // ミリ秒
                tap_distance_threshold: 20.0,      // ピクセル
                swipe_velocity_threshold: 0.3,     // ピクセル/ミリ秒
            }
        }
        
        // タッチイベントの処理
        pub fn process_touch(&mut self, event: TouchEvent) -> Option<Gesture> {
            match event.phase {
                TouchPhase::Began => {
                    // 新しいタッチの開始
                    let touch = Touch {
                        id: event.id,
                        x: event.x,
                        y: event.y,
                        start_x: event.x,
                        start_y: event.y,
                        start_time: event.timestamp,
                    };
                    
                    self.active_touches.insert(event.id, touch);
                    
                    // 長押しの開始
                    self.long_press_timer = Some((event.id, event.x, event.y, event.timestamp));
                    
                    None
                },
                TouchPhase::Moved => {
                    if let Some(touch) = self.active_touches.get_mut(&event.id) {
                        // タッチの移動更新
                        touch.x = event.x;
                        touch.y = event.y;
                        
                        // 長押しキャンセル判定
                        if let Some((id, start_x, start_y, _)) = self.long_press_timer {
                            if id == event.id {
                                let dx = event.x - start_x;
                                let dy = event.y - start_y;
                                let distance = (dx * dx + dy * dy).sqrt();
                                
                                if distance > self.tap_distance_threshold {
                                    self.long_press_timer = None;
                                }
                            }
                        }
                    }
                    
                    None
                },
                TouchPhase::Ended => {
                    // タッチの終了処理
                    if let Some(touch) = self.active_touches.remove(&event.id) {
                        // 長押しキャンセル
                        if let Some((id, _, _, _)) = self.long_press_timer {
                            if id == event.id {
                                self.long_press_timer = None;
                            }
                        }
                        
                        // 移動距離の計算
                        let dx = event.x - touch.start_x;
                        let dy = event.y - touch.start_y;
                        let distance = (dx * dx + dy * dy).sqrt();
                        
                        // タッチ期間の計算
                        let duration = event.timestamp - touch.start_time;
                        
                        if distance < self.tap_distance_threshold {
                            // タップ検出
                            let tap_position = (event.x, event.y);
                            let tap_time = event.timestamp;
                            
                            // ダブルタップ検出
                            let mut is_double_tap = false;
                            for i in (0..self.tap_history.len()).rev() {
                                let (prev_x, prev_y, prev_time) = self.tap_history[i];
                                let tap_dx = event.x - prev_x;
                                let tap_dy = event.y - prev_y;
                                let tap_distance = (tap_dx * tap_dx + tap_dy * tap_dy).sqrt();
                                
                                if tap_time - prev_time < self.double_tap_time_threshold && 
                                   tap_distance < self.tap_distance_threshold {
                                    is_double_tap = true;
                                    self.tap_history.remove(i);
                                    break;
                                }
                            }
                            
                            if is_double_tap {
                                return Some(Gesture::DoubleTap {
                                    position: tap_position,
                                    time: tap_time,
                                });
                            } else {
                                self.tap_history.push((tap_position.0, tap_position.1, tap_time));
                                if self.tap_history.len() > 5 {
                                    self.tap_history.remove(0);
                                }
                                
                                return Some(Gesture::Tap {
                                    position: tap_position,
                                    time: tap_time,
                                });
                            }
                        } else {
                            // スワイプ検出
                            let velocity = distance / duration as f32;
                            if velocity >= self.swipe_velocity_threshold {
                                let direction_x = dx / distance;
                                let direction_y = dy / distance;
                                
                                return Some(Gesture::Swipe {
                                    start_position: (touch.start_x, touch.start_y),
                                    end_position: (event.x, event.y),
                                    direction: (direction_x, direction_y),
                                    velocity,
                                    time: event.timestamp,
                                });
                            }
                        }
                    }
                    
                    None
                },
                TouchPhase::Cancelled => {
                    // タッチのキャンセル
                    self.active_touches.remove(&event.id);
                    
                    // 長押しキャンセル
                    if let Some((id, _, _, _)) = self.long_press_timer {
                        if id == event.id {
                            self.long_press_timer = None;
                        }
                    }
                    
                    None
                }
            }
        }
        
        // ジェスチャー更新（毎フレーム呼び出し）
        pub fn update(&mut self, _delta_time: f32) -> Option<Gesture> {
            // 長押し検出
            if let Some((id, x, y, start_time)) = self.long_press_timer {
                let current_time = web_sys::window().unwrap().performance().unwrap().now();
                let duration = current_time - start_time;
                
                if duration >= self.long_press_time_threshold {
                    self.long_press_timer = None;
                    return Some(Gesture::LongPress {
                        position: (x, y),
                        duration,
                    });
                }
            }
            
            // マルチタッチジェスチャー（ピンチ、回転）の検出
            if self.active_touches.len() >= 2 {
                let touches: Vec<&Touch> = self.active_touches.values().collect();
                
                // 2点間の情報を計算
                let (touch1, touch2) = (touches[0], touches[1]);
                
                // 中心点
                let center_x = (touch1.x + touch2.x) / 2.0;
                let center_y = (touch1.y + touch2.y) / 2.0;
                let start_center_x = (touch1.start_x + touch2.start_x) / 2.0;
                let start_center_y = (touch1.start_y + touch2.start_y) / 2.0;
                
                // 現在の距離
                let dx = touch2.x - touch1.x;
                let dy = touch2.y - touch1.y;
                let distance = (dx * dx + dy * dy).sqrt();
                
                // 開始時の距離
                let start_dx = touch2.start_x - touch1.start_x;
                let start_dy = touch2.start_y - touch1.start_y;
                let start_distance = (start_dx * start_dx + start_dy * start_dy).sqrt();
                
                // スケール（ピンチ）
                if start_distance > 0.0 {
                    let scale = distance / start_distance;
                    // スケールの変化が十分大きい場合
                    if (scale - 1.0).abs() > 0.1 {
                        return Some(Gesture::Pinch {
                            center: (center_x, center_y),
                            scale,
                            velocity: 0.0,  // 速度計算は省略
                        });
                    }
                }
                
                // 回転
                let current_angle = dy.atan2(dx);
                let start_angle = start_dy.atan2(start_dx);
                let angle_diff = current_angle - start_angle;
                
                // 角度の変化が十分大きい場合
                if angle_diff.abs() > 0.1 {
                    return Some(Gesture::Rotate {
                        center: (center_x, center_y),
                        angle: angle_diff,
                        velocity: 0.0,  // 速度計算は省略
                    });
                }
            }
            
            None
        }
    }
}
```

### 4. ネットワーク同期システム

```rust
pub struct NetworkSyncSystem {
    client: NetworkClient,
    last_sync_time: f64,
    sync_interval: f64,  // 秒
}

impl System for NetworkSyncSystem {
    fn run(&mut self, world: &mut World, _delta_time: f32) {
        let current_time = js_sys::Date::now();
        
        // 同期間隔ごとに処理
        if current_time - self.last_sync_time >= self.sync_interval {
            self.last_sync_time = current_time;
            
            // 1. サーバーへ送信するエンティティの状態を収集
            let player_entity = world.get_resource::<LocalPlayerResource>().unwrap().entity;
            self.sync_entity_to_server(world, player_entity);
            
            // 2. サーバーからの更新を処理
            self.process_server_updates(world);
        }
        
        // 毎フレーム処理: メッセージキューを確認
        self.process_message_queue(world);
    }
}

impl NetworkSyncSystem {
    pub fn new(server_url: &str, sync_interval: f64) -> Self {
        Self {
            client: NetworkClient::new(server_url),
            last_sync_time: 0.0,
            sync_interval,
        }
    }
    
    fn sync_entity_to_server(&mut self, world: &World, entity: EntityId) {
        // エンティティの重要なコンポーネントを収集
        let position = world.get_component::<Position>(entity).unwrap();
        let velocity = world.get_component::<Velocity>(entity).unwrap();
        
        // 必要なコンポーネントをシリアライズ
        let mut component_data = HashMap::new();
        component_data.insert("position".to_string(), serde_json::to_value(position).unwrap());
        component_data.insert("velocity".to_string(), serde_json::to_value(velocity).unwrap());
        
        // サーバーにメッセージ送信
        let message = NetworkMessage::EntityUpdate {
            entity_id: entity,
            components: component_data,
        };
        
        self.client.send_message(message);
    }
    
    fn process_server_updates(&mut self, world: &mut World) {
        // サーバーからの更新を適用
        while let Some(message) = self.client.receive_message() {
            match message {
                NetworkMessage::EntityUpdate { entity_id, components } => {
                    self.apply_entity_update(world, entity_id, components);
                },
                NetworkMessage::Join { player_id } => {
                    self.handle_player_join(world, player_id);
                },
                NetworkMessage::Leave { player_id } => {
                    self.handle_player_leave(world, player_id);
                },
                // その他のメッセージ処理...
                _ => {}
            }
        }
    }
    
    fn process_message_queue(&self, world: &mut World) {
        // 受信したメッセージの即時処理（レイテンシ低減のため）
        // ...
    }
    
    fn apply_entity_update(&self, world: &mut World, entity_id: EntityId, components: HashMap<String, serde_json::Value>) {
        // エンティティが存在しない場合は作成
        if !world.entity_exists(entity_id) {
            world.create_entity_with_id(entity_id);
        }
        
        // 各コンポーネントを更新
        if let Some(position_value) = components.get("position") {
            if let Ok(position) = serde_json::from_value::<Position>(position_value.clone()) {
                world.add_component(entity_id, position);
            }
        }
        
        if let Some(velocity_value) = components.get("velocity") {
            if let Ok(velocity) = serde_json::from_value::<Velocity>(velocity_value.clone()) {
                world.add_component(entity_id, velocity);
            }
        }
        
        // その他のコンポーネント...
    }
    
    fn handle_player_join(&self, world: &mut World, player_id: EntityId) {
        // 新規プレイヤーのエンティティを作成
        world.create_entity_with_id(player_id);
        world.add_component(player_id, Position::default());
        world.add_component(player_id, Velocity::default());
        world.add_component(player_id, RemotePlayer);
        // 必要に応じて他のコンポーネントも追加
    }
    
    fn handle_player_leave(&self, world: &mut World, player_id: EntityId) {
        // プレイヤーエンティティを削除
        world.delete_entity(player_id);
    }
}
```

### 5. アニメーションシステム

```rust
pub struct AnimationSystem;

impl System for AnimationSystem {
    fn run(&mut self, world: &mut World, delta_time: f32) {
        for entity in world.query::<&mut Animation>().iter() {
            let mut animation = world.get_component_mut::<Animation>(entity).unwrap();
            
            // アニメーションタイマーを更新
            animation.timer += delta_time;
            
            // フレームの更新が必要かチェック
            if animation.timer >= animation.frame_time {
                // タイマーをリセット（余りを保持）
                animation.timer %= animation.frame_time;
                
                // 次のフレームへ
                animation.current_frame = (animation.current_frame + 1) % animation.frame_count;
                
                // スプライトを更新
                if let Some(mut sprite) = world.get_component_mut::<Sprite>(entity) {
                    // フレームに基づいてスプライトのソース矩形を更新
                    sprite.source_x = animation.frame_width * animation.current_frame as f32;
                    // 必要に応じてY座標も更新（複数行のスプライトシートの場合）
                }
            }
        }
    }
}
```

### 6. 状態管理システム

```rust
pub struct GameStateSystem;

impl System for GameStateSystem {
    fn run(&mut self, world: &mut World, _delta_time: f32) {
        let game_state = world.get_resource::<GameStateResource>().unwrap();
        let current_state = game_state.current_state;
        
        match current_state {
            GameState::MainMenu => {
                // メインメニュー状態の処理
                self.process_main_menu(world);
            },
            GameState::Playing => {
                // ゲームプレイ状態の処理
                self.process_playing(world);
            },
            GameState::Paused => {
                // 一時停止状態の処理
                self.process_paused(world);
            },
            GameState::GameOver => {
                // ゲームオーバー状態の処理
                self.process_game_over(world);
            },
        }
        
        // 状態遷移の検出と処理
        self.check_state_transitions(world);
    }
}

impl GameStateSystem {
    fn process_main_menu(&self, world: &mut World) {
        // メインメニュー特有の処理
        // ...
    }
    
    fn process_playing(&self, world: &mut World) {
        // ゲームプレイ特有の処理
        // ...
    }
    
    fn process_paused(&self, world: &mut World) {
        // 一時停止特有の処理
        // ...
    }
    
    fn process_game_over(&self, world: &mut World) {
        // ゲームオーバー特有の処理
        // ...
    }
    
    fn check_state_transitions(&self, world: &mut World) {
        let mut game_state = world.get_resource_mut::<GameStateResource>().unwrap();
        let input = world.get_resource::<InputResource>().unwrap();
        
        // 状態遷移条件をチェック
        match game_state.current_state {
            GameState::MainMenu => {
                // スタートボタンが押されたかなど
                if input.keyboard.get(&13).copied().unwrap_or(false) {  // Enter キー
                    game_state.transition_to(GameState::Playing);
                }
            },
            GameState::Playing => {
                // ESCキーでポーズなど
                if input.keyboard.get(&27).copied().unwrap_or(false) {  // ESC キー
                    game_state.transition_to(GameState::Paused);
                }
                
                // ゲームオーバー条件
                if self.check_game_over_condition(world) {
                    game_state.transition_to(GameState::GameOver);
                }
            },
            GameState::Paused => {
                // ESCキーでポーズ解除など
                if input.keyboard.get(&27).copied().unwrap_or(false) {  // ESC キー
                    game_state.transition_to(GameState::Playing);
                }
            },
            GameState::GameOver => {
                // リトライキーなど
                if input.keyboard.get(&82).copied().unwrap_or(false) {  // R キー
                    game_state.transition_to(GameState::Playing);
                    self.reset_game(world);
                }
            },
        }
    }
    
    fn check_game_over_condition(&self, world: &World) -> bool {
        // ゲームオーバー条件をチェック（プレイヤーのライフがゼロなど）
        // ...
        false
    }
    
    fn reset_game(&self, world: &mut World) {
        // ゲームをリセット
        // エンティティのリセット、スコアのリセットなど
        // ...
    }
}
```

## システム間の依存関係と実行順序

システムの実行順序は、依存関係と処理の論理的な流れに基づいて決定されます。

### 標準的な実行順序

1. **入力処理システム** - プレイヤー入力を最初に処理
2. **ゲーム状態システム** - ゲームの状態を更新
3. **AIシステム** - NPCの動作を決定
4. **物理/衝突システム** - エンティティの移動と衝突を処理
5. **アニメーションシステム** - ビジュアル状態を更新
6. **ネットワーク同期システム** - リモートエンティティを同期
7. **レンダリングシステム** - 最終的な描画処理

### システム依存グラフ

```
InputSystem → GameStateSystem → AISystem → PhysicsSystem → AnimationSystem → NetworkSyncSystem → RenderingSystem
    ↓                                           ↓
    └───────────────────→ PlayerSystem ←────────┘
```

### パイプラインとステージ

```rust
pub fn setup_game_pipeline(world: &mut World) -> Schedule {
    Schedule::new()
        .add_stage(
            SystemStage::new("input")
                .with_system(InputSystem)
                .with_parallel(false)
        )
        .add_stage(
            SystemStage::new("game_logic")
                .with_system(GameStateSystem)
                .with_system(AISystem)
                .with_system(PlayerSystem)
                .with_parallel(true)  // これらは並列実行可能
        )
        .add_stage(
            SystemStage::new("physics")
                .with_system(PhysicsSystem)
                .with_parallel(false)
        )
        .add_stage(
            SystemStage::new("animation")
                .with_system(AnimationSystem)
                .with_parallel(true)
        )
        .add_stage(
            SystemStage::new("network")
                .with_system(NetworkSyncSystem)
                .with_parallel(false)
        )
        .add_stage(
            SystemStage::new("rendering")
                .with_system(RenderingSystem)
                .with_parallel(false)
        )
}
```

## 性能最適化テクニック

1. **システム実行の並列化** - 独立したシステムを並列実行
2. **エンティティのフィルタリング** - 関連コンポーネントを持つエンティティのみを処理
3. **システムの実行頻度調整** - 重要度に応じて実行頻度を変える
4. **バッチ処理** - 同種の処理をまとめて実行
5. **遅延処理** - 非クリティカルな処理を遅延させる

## コンポーネントとシステムの対応関係

| コンポーネント | 関連システム |
|--------------|------------|
| Position     | MovementSystem, PhysicsSystem, RenderingSystem |
| Velocity     | MovementSystem, PhysicsSystem |
| Sprite       | RenderingSystem |
| Animation    | AnimationSystem |
| Collider     | PhysicsSystem |
| PlayerControlled | InputSystem |
| AI           | AISystem |
| NetworkSync  | NetworkSyncSystem |

## システム特有のリソース

```rust
// レンダリングリソース
pub struct RenderingResource {
    pub sprite_sheet_cache: HashMap<String, HtmlImageElement>,
    pub z_layers: Vec<Vec<EntityId>>,
    pub view_width: u32,
    pub view_height: u32,
}

// カメラリソース
pub struct CameraResource {
    pub position: Position,
    pub zoom: f32,
    pub target_entity: Option<EntityId>,
    pub bounds: Option<(f32, f32, f32, f32)>,  // min_x, min_y, max_x, max_y
}

// 物理シミュレーションリソース
pub struct PhysicsResource {
    pub gravity: f32,
    pub collision_iterations: u32,
    pub velocity_iterations: u32,
}

// ゲーム状態リソース
pub struct GameStateResource {
    pub current_state: GameState,
    pub previous_state: Option<GameState>,
    pub transition_time: f32,
}

// ネットワークリソース
pub struct NetworkResource {
    pub client_id: String,
    pub server_time: f64,
    pub client_time: f64,
    pub rtt: f64,  // Round Trip Time
    pub time_sync_factor: f64,
}

// ローカルプレイヤーリソース
pub struct LocalPlayerResource {
    pub entity: EntityId,
    pub name: String,
    pub input_buffer: VecDeque<PlayerInput>,
}
``` 
``` 