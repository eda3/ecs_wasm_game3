# システム設計

ECSアーキテクチャにおけるシステムは、ゲームのロジックを実装する中心的な要素です。各システムは特定のタスクに焦点を当て、関連するコンポーネントを持つエンティティに対して処理を行います。

## システム設計原則

1. **単一責任の原則** - 各システムは明確に定義された一つの責任を持つ
2. **データ指向設計** - データ（コンポーネント）の流れに注目した設計
3. **疎結合** - システム間の依存関係を最小限に抑える
4. **再利用性** - 汎用的なシステムを設計し、異なるコンテキストで再利用可能に
5. **テスト容易性** - システムの動作を個別にテストできるような設計

## コアシステム

### 1. レンダリングシステム

```rust
pub struct RenderingSystem {
    canvas_context: CanvasRenderingContext2d,
}

impl System for RenderingSystem {
    fn run(&mut self, world: &mut World, _delta_time: f32) {
        // キャンバスをクリア
        self.canvas_context.clear_rect(
            0.0, 0.0,
            self.canvas_context.canvas().unwrap().width() as f64,
            self.canvas_context.canvas().unwrap().height() as f64,
        );
        
        // カメラ設定を取得
        let camera = world.get_resource::<CameraResource>().unwrap();
        
        // 描画エンティティのクエリ（Position + Spriteを持つエンティティ）
        let render_query = world.query::<(&Position, &Sprite)>();
        
        // 描画順にソート（Z-orderなど）
        // ...ソートロジック...
        
        // 各エンティティを描画
        for (entity, (position, sprite)) in render_query.iter_with_components() {
            // スプライトのレンダリング
            self.canvas_context.save();
            self.canvas_context.translate(
                (position.x - camera.position.x) as f64,
                (position.y - camera.position.y) as f64,
            );
            
            // スプライト描画ロジック
            // ...
            
            self.canvas_context.restore();
        }
        
        // UIレイヤーの描画
        self.render_ui(world);
    }
}

impl RenderingSystem {
    pub fn new(canvas_context: CanvasRenderingContext2d) -> Self {
        Self { canvas_context }
    }
    
    fn render_ui(&self, world: &World) {
        // UIコンポーネントの描画
        // ...
    }
}
```

### 2. 物理/衝突システム

物理システムは以下の主要コンポーネントで構成されています：

#### 2.1 衝突検出システム

```rust
pub mod collision {
    /// 衝突形状の定義
    pub enum CollisionShape {
        /// 円形
        Circle {
            /// 半径
            radius: f64,
        },
        /// AABB（軸並行境界ボックス）
        AABB {
            /// 幅
            width: f64,
            /// 高さ
            height: f64,
        },
        /// 多角形
        Polygon {
            /// 頂点座標のリスト（ローカル座標）
            vertices: Vec<(f64, f64)>,
        },
    }

    /// 衝突情報
    pub struct Collision {
        /// 衝突点の位置
        pub position: (f64, f64),
        /// 衝突の法線ベクトル（衝突面の垂直方向）
        pub normal: (f64, f64),
        /// 貫通深度
        pub penetration: f64,
    }

    /// 2つのエンティティ間の衝突を検出
    pub fn detect_collision(entity_a: &PhysicsEntity, entity_b: &PhysicsEntity) -> Option<Collision> {
        // 形状タイプに基づいて適切な検出関数を呼び出し
        match (&entity_a.shape, &entity_b.shape) {
            (CollisionShape::Circle { radius: radius_a }, CollisionShape::Circle { radius: radius_b }) => {
                detect_circle_circle(entity_a.position, *radius_a, entity_b.position, *radius_b)
            },
            (CollisionShape::AABB { width: width_a, height: height_a }, 
             CollisionShape::AABB { width: width_b, height: height_b }) => {
                detect_aabb_aabb(entity_a.position, *width_a, *height_a, 
                                entity_b.position, *width_b, *height_b)
            },
            // その他の組み合わせは省略...
        }
    }
}
```

#### 2.2 物理演算システム

```rust
pub mod dynamics {
    /// 衝突解決器
    pub struct CollisionResolver {
        /// 位置補正の割合（0-1）
        position_correction_rate: f64,
        /// イテレーション回数
        iterations: usize,
    }

    impl CollisionResolver {
        /// 衝突を解決
        pub fn resolve_collision(
            &self,
            entity_a: &mut PhysicsEntity,
            entity_b: &mut PhysicsEntity,
            collision: &Collision,
        ) {
            // 静的物体の場合は処理を分岐
            if entity_a.is_static && entity_b.is_static {
                return;
            } else if entity_a.is_static {
                self.resolve_collision_one_sided(entity_b, entity_a, collision, true);
                return;
            } else if entity_b.is_static {
                self.resolve_collision_one_sided(entity_a, entity_b, collision, false);
                return;
            }
            
            // 衝撃計算と速度更新
            // ...省略...
            
            // 摩擦力の適用
            self.apply_friction(entity_a, entity_b, collision, inverse_mass_a, inverse_mass_b, j);
            
            // 位置補正（めり込み解消）
            self.correct_position(entity_a, entity_b, collision);
        }
    }

    /// 積分器（運動方程式の数値積分）
    pub struct Integrator {
        /// 最大速度
        max_velocity: f64,
        /// 最大角速度
        max_angular_velocity: f64,
    }

    impl Integrator {
        /// 物理エンティティを更新（オイラー法）
        pub fn integrate(&self, entity: &mut PhysicsEntity, dt: f64, gravity: (f64, f64), damping: f64) {
            if entity.is_static {
                return;
            }
            
            // 加速度、速度、位置の更新
            // ...省略...
            
            // 角度の更新
            // ...省略...
        }
    }

    /// 力の生成器
    pub struct ForceGenerator {
        /// 重力定数
        gravity: (f64, f64),
    }

    impl ForceGenerator {
        /// 力を適用
        pub fn apply_force(&self, entity: &mut PhysicsEntity, force: (f64, f64)) {
            // F = ma より a = F/m
            // ...省略...
        }

        /// トルクを適用
        pub fn apply_torque(&self, entity: &mut PhysicsEntity, torque: f64) {
            // ...省略...
        }
        
        /// 特定の位置に力を適用（トルクも生成）
        pub fn apply_force_at_point(
            &self,
            entity: &mut PhysicsEntity,
            force: (f64, f64),
            application_point: (f64, f64),
        ) {
            // ...省略...
        }
        
        /// ばね力を適用
        pub fn apply_spring_force(
            &self,
            entity: &mut PhysicsEntity,
            anchor_point: (f64, f64),
            rest_length: f64,
            spring_constant: f64,
        ) {
            // ...省略...
        }
        
        /// 抗力（空気抵抗など）を適用
        pub fn apply_drag_force(
            &self,
            entity: &mut PhysicsEntity,
            drag_coefficient: f64,
        ) {
            // ...省略...
        }
    }
}
```

#### 2.3 物理最適化システム（予定）

```rust
pub mod optimization {
    /// 空間分割グリッド
    pub struct SpatialGrid {
        /// セルのサイズ
        cell_size: f64,
        /// グリッドのセル（キー: セルID, 値: エンティティIDのリスト）
        cells: HashMap<(i32, i32), Vec<u32>>,
    }

    /// 衝突フィルタリング
    pub struct CollisionFilter {
        /// 衝突フィルターのマスク（キー: エンティティID, 値: フィルターマスク）
        masks: HashMap<u32, u32>,
        /// 衝突フィルターのカテゴリ（キー: エンティティID, 値: カテゴリ）
        categories: HashMap<u32, u32>,
    }

    /// 物理ステップ最適化
    pub struct PhysicsStep {
        /// 累積時間
        accumulated_time: f64,
        /// 固定時間ステップ
        fixed_time_step: f64,
        /// 最大ステップ数
        max_steps_per_update: usize,
    }
}
```

### 3. 入力処理システム

```rust
pub struct InputSystem;

impl System for InputSystem {
    fn run(&mut self, world: &mut World, _delta_time: f32) {
        // 入力リソースを取得
        let input = world.get_resource::<InputResource>().unwrap();
        
        // 入力を処理するエンティティを取得（PlayerControlledコンポーネントを持つもの）
        for entity in world.query::<&PlayerControlled>().iter() {
            let mut velocity = world.get_component_mut::<Velocity>(entity).unwrap();
            
            // キーボード入力による移動処理
            velocity.x = 0.0;  // リセット
            
            if input.keyboard.get(&37).copied().unwrap_or(false) {  // 左矢印キー
                velocity.x -= 5.0;
            }
            if input.keyboard.get(&39).copied().unwrap_or(false) {  // 右矢印キー
                velocity.x += 5.0;
            }
            
            // ジャンプ処理
            if input.keyboard.get(&38).copied().unwrap_or(false) {  // 上矢印キー
                // ジャンプは地上にいる場合のみ
                if let Some(grounded) = world.get_component::<Grounded>(entity) {
                    if grounded.is_grounded {
                        velocity.y = -10.0;  // 上向きに力を加える
                    }
                }
            }
            
            // その他の入力処理...
        }
    }
}
```

### 4. ネットワーク同期システム

```rust
pub struct NetworkSyncSystem {
    client: NetworkClient,
    last_sync_time: f64,
    sync_interval: f64,  // 秒
}

impl System for NetworkSyncSystem {
    fn run(&mut self, world: &mut World, _delta_time: f32) {
        let current_time = js_sys::Date::now();
        
        // 同期間隔ごとに処理
        if current_time - self.last_sync_time >= self.sync_interval {
            self.last_sync_time = current_time;
            
            // 1. サーバーへ送信するエンティティの状態を収集
            let player_entity = world.get_resource::<LocalPlayerResource>().unwrap().entity;
            self.sync_entity_to_server(world, player_entity);
            
            // 2. サーバーからの更新を処理
            self.process_server_updates(world);
        }
        
        // 毎フレーム処理: メッセージキューを確認
        self.process_message_queue(world);
    }
}

impl NetworkSyncSystem {
    pub fn new(server_url: &str, sync_interval: f64) -> Self {
        Self {
            client: NetworkClient::new(server_url),
            last_sync_time: 0.0,
            sync_interval,
        }
    }
    
    fn sync_entity_to_server(&mut self, world: &World, entity: EntityId) {
        // エンティティの重要なコンポーネントを収集
        let position = world.get_component::<Position>(entity).unwrap();
        let velocity = world.get_component::<Velocity>(entity).unwrap();
        
        // 必要なコンポーネントをシリアライズ
        let mut component_data = HashMap::new();
        component_data.insert("position".to_string(), serde_json::to_value(position).unwrap());
        component_data.insert("velocity".to_string(), serde_json::to_value(velocity).unwrap());
        
        // サーバーにメッセージ送信
        let message = NetworkMessage::EntityUpdate {
            entity_id: entity,
            components: component_data,
        };
        
        self.client.send_message(message);
    }
    
    fn process_server_updates(&mut self, world: &mut World) {
        // サーバーからの更新を適用
        while let Some(message) = self.client.receive_message() {
            match message {
                NetworkMessage::EntityUpdate { entity_id, components } => {
                    self.apply_entity_update(world, entity_id, components);
                },
                NetworkMessage::Join { player_id } => {
                    self.handle_player_join(world, player_id);
                },
                NetworkMessage::Leave { player_id } => {
                    self.handle_player_leave(world, player_id);
                },
                // その他のメッセージ処理...
                _ => {}
            }
        }
    }
    
    fn process_message_queue(&self, world: &mut World) {
        // 受信したメッセージの即時処理（レイテンシ低減のため）
        // ...
    }
    
    fn apply_entity_update(&self, world: &mut World, entity_id: EntityId, components: HashMap<String, serde_json::Value>) {
        // エンティティが存在しない場合は作成
        if !world.entity_exists(entity_id) {
            world.create_entity_with_id(entity_id);
        }
        
        // 各コンポーネントを更新
        if let Some(position_value) = components.get("position") {
            if let Ok(position) = serde_json::from_value::<Position>(position_value.clone()) {
                world.add_component(entity_id, position);
            }
        }
        
        if let Some(velocity_value) = components.get("velocity") {
            if let Ok(velocity) = serde_json::from_value::<Velocity>(velocity_value.clone()) {
                world.add_component(entity_id, velocity);
            }
        }
        
        // その他のコンポーネント...
    }
    
    fn handle_player_join(&self, world: &mut World, player_id: EntityId) {
        // 新規プレイヤーのエンティティを作成
        world.create_entity_with_id(player_id);
        world.add_component(player_id, Position::default());
        world.add_component(player_id, Velocity::default());
        world.add_component(player_id, RemotePlayer);
        // 必要に応じて他のコンポーネントも追加
    }
    
    fn handle_player_leave(&self, world: &mut World, player_id: EntityId) {
        // プレイヤーエンティティを削除
        world.delete_entity(player_id);
    }
}
```

### 5. アニメーションシステム

```rust
pub struct AnimationSystem;

impl System for AnimationSystem {
    fn run(&mut self, world: &mut World, delta_time: f32) {
        for entity in world.query::<&mut Animation>().iter() {
            let mut animation = world.get_component_mut::<Animation>(entity).unwrap();
            
            // アニメーションタイマーを更新
            animation.timer += delta_time;
            
            // フレームの更新が必要かチェック
            if animation.timer >= animation.frame_time {
                // タイマーをリセット（余りを保持）
                animation.timer %= animation.frame_time;
                
                // 次のフレームへ
                animation.current_frame = (animation.current_frame + 1) % animation.frame_count;
                
                // スプライトを更新
                if let Some(mut sprite) = world.get_component_mut::<Sprite>(entity) {
                    // フレームに基づいてスプライトのソース矩形を更新
                    sprite.source_x = animation.frame_width * animation.current_frame as f32;
                    // 必要に応じてY座標も更新（複数行のスプライトシートの場合）
                }
            }
        }
    }
}
```

### 6. 状態管理システム

```rust
pub struct GameStateSystem;

impl System for GameStateSystem {
    fn run(&mut self, world: &mut World, _delta_time: f32) {
        let game_state = world.get_resource::<GameStateResource>().unwrap();
        let current_state = game_state.current_state;
        
        match current_state {
            GameState::MainMenu => {
                // メインメニュー状態の処理
                self.process_main_menu(world);
            },
            GameState::Playing => {
                // ゲームプレイ状態の処理
                self.process_playing(world);
            },
            GameState::Paused => {
                // 一時停止状態の処理
                self.process_paused(world);
            },
            GameState::GameOver => {
                // ゲームオーバー状態の処理
                self.process_game_over(world);
            },
        }
        
        // 状態遷移の検出と処理
        self.check_state_transitions(world);
    }
}

impl GameStateSystem {
    fn process_main_menu(&self, world: &mut World) {
        // メインメニュー特有の処理
        // ...
    }
    
    fn process_playing(&self, world: &mut World) {
        // ゲームプレイ特有の処理
        // ...
    }
    
    fn process_paused(&self, world: &mut World) {
        // 一時停止特有の処理
        // ...
    }
    
    fn process_game_over(&self, world: &mut World) {
        // ゲームオーバー特有の処理
        // ...
    }
    
    fn check_state_transitions(&self, world: &mut World) {
        let mut game_state = world.get_resource_mut::<GameStateResource>().unwrap();
        let input = world.get_resource::<InputResource>().unwrap();
        
        // 状態遷移条件をチェック
        match game_state.current_state {
            GameState::MainMenu => {
                // スタートボタンが押されたかなど
                if input.keyboard.get(&13).copied().unwrap_or(false) {  // Enter キー
                    game_state.transition_to(GameState::Playing);
                }
            },
            GameState::Playing => {
                // ESCキーでポーズなど
                if input.keyboard.get(&27).copied().unwrap_or(false) {  // ESC キー
                    game_state.transition_to(GameState::Paused);
                }
                
                // ゲームオーバー条件
                if self.check_game_over_condition(world) {
                    game_state.transition_to(GameState::GameOver);
                }
            },
            GameState::Paused => {
                // ESCキーでポーズ解除など
                if input.keyboard.get(&27).copied().unwrap_or(false) {  // ESC キー
                    game_state.transition_to(GameState::Playing);
                }
            },
            GameState::GameOver => {
                // リトライキーなど
                if input.keyboard.get(&82).copied().unwrap_or(false) {  // R キー
                    game_state.transition_to(GameState::Playing);
                    self.reset_game(world);
                }
            },
        }
    }
    
    fn check_game_over_condition(&self, world: &World) -> bool {
        // ゲームオーバー条件をチェック（プレイヤーのライフがゼロなど）
        // ...
        false
    }
    
    fn reset_game(&self, world: &mut World) {
        // ゲームをリセット
        // エンティティのリセット、スコアのリセットなど
        // ...
    }
}
```

## システム間の依存関係と実行順序

システムの実行順序は、依存関係と処理の論理的な流れに基づいて決定されます。

### 標準的な実行順序

1. **入力処理システム** - プレイヤー入力を最初に処理
2. **ゲーム状態システム** - ゲームの状態を更新
3. **AIシステム** - NPCの動作を決定
4. **物理/衝突システム** - エンティティの移動と衝突を処理
5. **アニメーションシステム** - ビジュアル状態を更新
6. **ネットワーク同期システム** - リモートエンティティを同期
7. **レンダリングシステム** - 最終的な描画処理

### システム依存グラフ

```
InputSystem → GameStateSystem → AISystem → PhysicsSystem → AnimationSystem → NetworkSyncSystem → RenderingSystem
    ↓                                           ↓
    └───────────────────→ PlayerSystem ←────────┘
```

### パイプラインとステージ

```rust
pub fn setup_game_pipeline(world: &mut World) -> Schedule {
    Schedule::new()
        .add_stage(
            SystemStage::new("input")
                .with_system(InputSystem)
                .with_parallel(false)
        )
        .add_stage(
            SystemStage::new("game_logic")
                .with_system(GameStateSystem)
                .with_system(AISystem)
                .with_system(PlayerSystem)
                .with_parallel(true)  // これらは並列実行可能
        )
        .add_stage(
            SystemStage::new("physics")
                .with_system(PhysicsSystem)
                .with_parallel(false)
        )
        .add_stage(
            SystemStage::new("animation")
                .with_system(AnimationSystem)
                .with_parallel(true)
        )
        .add_stage(
            SystemStage::new("network")
                .with_system(NetworkSyncSystem)
                .with_parallel(false)
        )
        .add_stage(
            SystemStage::new("rendering")
                .with_system(RenderingSystem)
                .with_parallel(false)
        )
}
```

## 性能最適化テクニック

1. **システム実行の並列化** - 独立したシステムを並列実行
2. **エンティティのフィルタリング** - 関連コンポーネントを持つエンティティのみを処理
3. **システムの実行頻度調整** - 重要度に応じて実行頻度を変える
4. **バッチ処理** - 同種の処理をまとめて実行
5. **遅延処理** - 非クリティカルな処理を遅延させる

## コンポーネントとシステムの対応関係

| コンポーネント | 関連システム |
|--------------|------------|
| Position     | MovementSystem, PhysicsSystem, RenderingSystem |
| Velocity     | MovementSystem, PhysicsSystem |
| Sprite       | RenderingSystem |
| Animation    | AnimationSystem |
| Collider     | PhysicsSystem |
| PlayerControlled | InputSystem |
| AI           | AISystem |
| NetworkSync  | NetworkSyncSystem |

## システム特有のリソース

```rust
// レンダリングリソース
pub struct RenderingResource {
    pub sprite_sheet_cache: HashMap<String, HtmlImageElement>,
    pub z_layers: Vec<Vec<EntityId>>,
    pub view_width: u32,
    pub view_height: u32,
}

// カメラリソース
pub struct CameraResource {
    pub position: Position,
    pub zoom: f32,
    pub target_entity: Option<EntityId>,
    pub bounds: Option<(f32, f32, f32, f32)>,  // min_x, min_y, max_x, max_y
}

// 物理シミュレーションリソース
pub struct PhysicsResource {
    pub gravity: f32,
    pub collision_iterations: u32,
    pub velocity_iterations: u32,
}

// ゲーム状態リソース
pub struct GameStateResource {
    pub current_state: GameState,
    pub previous_state: Option<GameState>,
    pub transition_time: f32,
}

// ネットワークリソース
pub struct NetworkResource {
    pub client_id: String,
    pub server_time: f64,
    pub client_time: f64,
    pub rtt: f64,  // Round Trip Time
    pub time_sync_factor: f64,
}

// ローカルプレイヤーリソース
pub struct LocalPlayerResource {
    pub entity: EntityId,
    pub name: String,
    pub input_buffer: VecDeque<PlayerInput>,
}
``` 
``` 