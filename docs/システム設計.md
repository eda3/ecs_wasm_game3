# システム設計

ECSアーキテクチャにおけるシステムは、ゲームのロジックを実装する中心的な要素です。各システムは特定のタスクに焦点を当て、関連するコンポーネントを持つエンティティに対して処理を行います。

## システム設計原則

1. **単一責任の原則** - 各システムは明確に定義された一つの責任を持つ
2. **データ指向設計** - データ（コンポーネント）の流れに注目した設計
3. **疎結合** - システム間の依存関係を最小限に抑える
4. **再利用性** - 汎用的なシステムを設計し、異なるコンテキストで再利用可能に
5. **テスト容易性** - システムの動作を個別にテストできるような設計

## コアシステム

### 1. レンダリングシステム

```rust
pub struct RenderingSystem {
    canvas_context: CanvasRenderingContext2d,
}

impl System for RenderingSystem {
    fn run(&mut self, world: &mut World, _delta_time: f32) {
        // キャンバスをクリア
        self.canvas_context.clear_rect(
            0.0, 0.0,
            self.canvas_context.canvas().unwrap().width() as f64,
            self.canvas_context.canvas().unwrap().height() as f64,
        );
        
        // カメラ設定を取得
        let camera = world.get_resource::<CameraResource>().unwrap();
        
        // 描画エンティティのクエリ（Position + Spriteを持つエンティティ）
        let render_query = world.query::<(&Position, &Sprite)>();
        
        // 描画順にソート（Z-orderなど）
        // ...ソートロジック...
        
        // 各エンティティを描画
        for (entity, (position, sprite)) in render_query.iter_with_components() {
            // スプライトのレンダリング
            self.canvas_context.save();
            self.canvas_context.translate(
                (position.x - camera.position.x) as f64,
                (position.y - camera.position.y) as f64,
            );
            
            // スプライト描画ロジック
            // ...
            
            self.canvas_context.restore();
        }
        
        // UIレイヤーの描画
        self.render_ui(world);
    }
}

impl RenderingSystem {
    pub fn new(canvas_context: CanvasRenderingContext2d) -> Self {
        Self { canvas_context }
    }
    
    fn render_ui(&self, world: &World) {
        // UIコンポーネントの描画
        // ...
    }
}
```

### 2. 物理/衝突システム

```rust
pub struct PhysicsSystem {
    gravity: f32,
    collision_layers: HashMap<u8, Vec<EntityId>>,
}

impl System for PhysicsSystem {
    fn run(&mut self, world: &mut World, delta_time: f32) {
        // 1. 重力適用
        self.apply_gravity(world, delta_time);
        
        // 2. 速度適用（位置更新）
        self.apply_velocity(world, delta_time);
        
        // 3. 衝突検出
        let collisions = self.detect_collisions(world);
        
        // 4. 衝突解決
        self.resolve_collisions(world, &collisions);
        
        // 5. 衝突イベント発行
        let mut collision_events = world.get_resource_mut::<EventQueue<CollisionEvent>>().unwrap();
        for collision in collisions {
            collision_events.send(collision);
        }
    }
}

impl PhysicsSystem {
    pub fn new(gravity: f32) -> Self {
        Self {
            gravity,
            collision_layers: HashMap::new(),
        }
    }
    
    fn apply_gravity(&self, world: &mut World, delta_time: f32) {
        // 重力コンポーネントを持つエンティティに重力を適用
        for entity in world.query::<(&mut Velocity, &GravityAffected)>().iter() {
            let mut velocity = world.get_component_mut::<Velocity>(entity).unwrap();
            velocity.y += self.gravity * delta_time;
        }
    }
    
    fn apply_velocity(&self, world: &mut World, delta_time: f32) {
        // 速度を位置に適用
        for entity in world.query::<(&mut Position, &Velocity)>().iter() {
            let velocity = world.get_component::<Velocity>(entity).unwrap();
            let mut position = world.get_component_mut::<Position>(entity).unwrap();
            
            position.x += velocity.x * delta_time;
            position.y += velocity.y * delta_time;
        }
    }
    
    fn detect_collisions(&mut self, world: &World) -> Vec<CollisionEvent> {
        let mut collisions = Vec::new();
        
        // 衝突レイヤーごとにエンティティを整理
        self.update_collision_layers(world);
        
        // 各レイヤー内および異なるレイヤー間の衝突をチェック
        // ...衝突検出アルゴリズム...
        
        collisions
    }
    
    fn resolve_collisions(&self, world: &mut World, collisions: &[CollisionEvent]) {
        for collision in collisions {
            // 衝突解決ロジック（位置補正、速度反射など）
            // ...
        }
    }
    
    fn update_collision_layers(&mut self, world: &World) {
        self.collision_layers.clear();
        
        // Colliderコンポーネントを持つエンティティをレイヤーごとに分類
        for (entity, collider) in world.query::<&Collider>().iter_with_components() {
            self.collision_layers.entry(collider.layer)
                .or_insert_with(Vec::new)
                .push(entity);
        }
    }
}
```

### 3. 入力処理システム

```rust
pub struct InputSystem;

impl System for InputSystem {
    fn run(&mut self, world: &mut World, _delta_time: f32) {
        // 入力リソースを取得
        let input = world.get_resource::<InputResource>().unwrap();
        
        // 入力を処理するエンティティを取得（PlayerControlledコンポーネントを持つもの）
        for entity in world.query::<&PlayerControlled>().iter() {
            let mut velocity = world.get_component_mut::<Velocity>(entity).unwrap();
            
            // キーボード入力による移動処理
            velocity.x = 0.0;  // リセット
            
            if input.keyboard.get(&37).copied().unwrap_or(false) {  // 左矢印キー
                velocity.x -= 5.0;
            }
            if input.keyboard.get(&39).copied().unwrap_or(false) {  // 右矢印キー
                velocity.x += 5.0;
            }
            
            // ジャンプ処理
            if input.keyboard.get(&38).copied().unwrap_or(false) {  // 上矢印キー
                // ジャンプは地上にいる場合のみ
                if let Some(grounded) = world.get_component::<Grounded>(entity) {
                    if grounded.is_grounded {
                        velocity.y = -10.0;  // 上向きに力を加える
                    }
                }
            }
            
            // その他の入力処理...
        }
    }
}
```

### 4. ネットワーク同期システム

```rust
pub struct NetworkSyncSystem {
    client: NetworkClient,
    last_sync_time: f64,
    sync_interval: f64,  // 秒
}

impl System for NetworkSyncSystem {
    fn run(&mut self, world: &mut World, _delta_time: f32) {
        let current_time = js_sys::Date::now();
        
        // 同期間隔ごとに処理
        if current_time - self.last_sync_time >= self.sync_interval {
            self.last_sync_time = current_time;
            
            // 1. サーバーへ送信するエンティティの状態を収集
            let player_entity = world.get_resource::<LocalPlayerResource>().unwrap().entity;
            self.sync_entity_to_server(world, player_entity);
            
            // 2. サーバーからの更新を処理
            self.process_server_updates(world);
        }
        
        // 毎フレーム処理: メッセージキューを確認
        self.process_message_queue(world);
    }
}

impl NetworkSyncSystem {
    pub fn new(server_url: &str, sync_interval: f64) -> Self {
        Self {
            client: NetworkClient::new(server_url),
            last_sync_time: 0.0,
            sync_interval,
        }
    }
    
    fn sync_entity_to_server(&mut self, world: &World, entity: EntityId) {
        // エンティティの重要なコンポーネントを収集
        let position = world.get_component::<Position>(entity).unwrap();
        let velocity = world.get_component::<Velocity>(entity).unwrap();
        
        // 必要なコンポーネントをシリアライズ
        let mut component_data = HashMap::new();
        component_data.insert("position".to_string(), serde_json::to_value(position).unwrap());
        component_data.insert("velocity".to_string(), serde_json::to_value(velocity).unwrap());
        
        // サーバーにメッセージ送信
        let message = NetworkMessage::EntityUpdate {
            entity_id: entity,
            components: component_data,
        };
        
        self.client.send_message(message);
    }
    
    fn process_server_updates(&mut self, world: &mut World) {
        // サーバーからの更新を適用
        while let Some(message) = self.client.receive_message() {
            match message {
                NetworkMessage::EntityUpdate { entity_id, components } => {
                    self.apply_entity_update(world, entity_id, components);
                },
                NetworkMessage::Join { player_id } => {
                    self.handle_player_join(world, player_id);
                },
                NetworkMessage::Leave { player_id } => {
                    self.handle_player_leave(world, player_id);
                },
                // その他のメッセージ処理...
                _ => {}
            }
        }
    }
    
    fn process_message_queue(&self, world: &mut World) {
        // 受信したメッセージの即時処理（レイテンシ低減のため）
        // ...
    }
    
    fn apply_entity_update(&self, world: &mut World, entity_id: EntityId, components: HashMap<String, serde_json::Value>) {
        // エンティティが存在しない場合は作成
        if !world.entity_exists(entity_id) {
            world.create_entity_with_id(entity_id);
        }
        
        // 各コンポーネントを更新
        if let Some(position_value) = components.get("position") {
            if let Ok(position) = serde_json::from_value::<Position>(position_value.clone()) {
                world.add_component(entity_id, position);
            }
        }
        
        if let Some(velocity_value) = components.get("velocity") {
            if let Ok(velocity) = serde_json::from_value::<Velocity>(velocity_value.clone()) {
                world.add_component(entity_id, velocity);
            }
        }
        
        // その他のコンポーネント...
    }
    
    fn handle_player_join(&self, world: &mut World, player_id: EntityId) {
        // 新規プレイヤーのエンティティを作成
        world.create_entity_with_id(player_id);
        world.add_component(player_id, Position::default());
        world.add_component(player_id, Velocity::default());
        world.add_component(player_id, RemotePlayer);
        // 必要に応じて他のコンポーネントも追加
    }
    
    fn handle_player_leave(&self, world: &mut World, player_id: EntityId) {
        // プレイヤーエンティティを削除
        world.delete_entity(player_id);
    }
}
```

### 5. アニメーションシステム

```rust
pub struct AnimationSystem;

impl System for AnimationSystem {
    fn run(&mut self, world: &mut World, delta_time: f32) {
        for entity in world.query::<&mut Animation>().iter() {
            let mut animation = world.get_component_mut::<Animation>(entity).unwrap();
            
            // アニメーションタイマーを更新
            animation.timer += delta_time;
            
            // フレームの更新が必要かチェック
            if animation.timer >= animation.frame_time {
                // タイマーをリセット（余りを保持）
                animation.timer %= animation.frame_time;
                
                // 次のフレームへ
                animation.current_frame = (animation.current_frame + 1) % animation.frame_count;
                
                // スプライトを更新
                if let Some(mut sprite) = world.get_component_mut::<Sprite>(entity) {
                    // フレームに基づいてスプライトのソース矩形を更新
                    sprite.source_x = animation.frame_width * animation.current_frame as f32;
                    // 必要に応じてY座標も更新（複数行のスプライトシートの場合）
                }
            }
        }
    }
}
```

### 6. 状態管理システム

```rust
pub struct GameStateSystem;

impl System for GameStateSystem {
    fn run(&mut self, world: &mut World, _delta_time: f32) {
        let game_state = world.get_resource::<GameStateResource>().unwrap();
        let current_state = game_state.current_state;
        
        match current_state {
            GameState::MainMenu => {
                // メインメニュー状態の処理
                self.process_main_menu(world);
            },
            GameState::Playing => {
                // ゲームプレイ状態の処理
                self.process_playing(world);
            },
            GameState::Paused => {
                // 一時停止状態の処理
                self.process_paused(world);
            },
            GameState::GameOver => {
                // ゲームオーバー状態の処理
                self.process_game_over(world);
            },
        }
        
        // 状態遷移の検出と処理
        self.check_state_transitions(world);
    }
}

impl GameStateSystem {
    fn process_main_menu(&self, world: &mut World) {
        // メインメニュー特有の処理
        // ...
    }
    
    fn process_playing(&self, world: &mut World) {
        // ゲームプレイ特有の処理
        // ...
    }
    
    fn process_paused(&self, world: &mut World) {
        // 一時停止特有の処理
        // ...
    }
    
    fn process_game_over(&self, world: &mut World) {
        // ゲームオーバー特有の処理
        // ...
    }
    
    fn check_state_transitions(&self, world: &mut World) {
        let mut game_state = world.get_resource_mut::<GameStateResource>().unwrap();
        let input = world.get_resource::<InputResource>().unwrap();
        
        // 状態遷移条件をチェック
        match game_state.current_state {
            GameState::MainMenu => {
                // スタートボタンが押されたかなど
                if input.keyboard.get(&13).copied().unwrap_or(false) {  // Enter キー
                    game_state.transition_to(GameState::Playing);
                }
            },
            GameState::Playing => {
                // ESCキーでポーズなど
                if input.keyboard.get(&27).copied().unwrap_or(false) {  // ESC キー
                    game_state.transition_to(GameState::Paused);
                }
                
                // ゲームオーバー条件
                if self.check_game_over_condition(world) {
                    game_state.transition_to(GameState::GameOver);
                }
            },
            GameState::Paused => {
                // ESCキーでポーズ解除など
                if input.keyboard.get(&27).copied().unwrap_or(false) {  // ESC キー
                    game_state.transition_to(GameState::Playing);
                }
            },
            GameState::GameOver => {
                // リトライキーなど
                if input.keyboard.get(&82).copied().unwrap_or(false) {  // R キー
                    game_state.transition_to(GameState::Playing);
                    self.reset_game(world);
                }
            },
        }
    }
    
    fn check_game_over_condition(&self, world: &World) -> bool {
        // ゲームオーバー条件をチェック（プレイヤーのライフがゼロなど）
        // ...
        false
    }
    
    fn reset_game(&self, world: &mut World) {
        // ゲームをリセット
        // エンティティのリセット、スコアのリセットなど
        // ...
    }
}
```

## システム間の依存関係と実行順序

システムの実行順序は、依存関係と処理の論理的な流れに基づいて決定されます。

### 標準的な実行順序

1. **入力処理システム** - プレイヤー入力を最初に処理
2. **ゲーム状態システム** - ゲームの状態を更新
3. **AIシステム** - NPCの動作を決定
4. **物理/衝突システム** - エンティティの移動と衝突を処理
5. **アニメーションシステム** - ビジュアル状態を更新
6. **ネットワーク同期システム** - リモートエンティティを同期
7. **レンダリングシステム** - 最終的な描画処理

### システム依存グラフ

```
InputSystem → GameStateSystem → AISystem → PhysicsSystem → AnimationSystem → NetworkSyncSystem → RenderingSystem
    ↓                                           ↓
    └───────────────────→ PlayerSystem ←────────┘
```

### パイプラインとステージ

```rust
pub fn setup_game_pipeline(world: &mut World) -> Schedule {
    Schedule::new()
        .add_stage(
            SystemStage::new("input")
                .with_system(InputSystem)
                .with_parallel(false)
        )
        .add_stage(
            SystemStage::new("game_logic")
                .with_system(GameStateSystem)
                .with_system(AISystem)
                .with_system(PlayerSystem)
                .with_parallel(true)  // これらは並列実行可能
        )
        .add_stage(
            SystemStage::new("physics")
                .with_system(PhysicsSystem)
                .with_parallel(false)
        )
        .add_stage(
            SystemStage::new("animation")
                .with_system(AnimationSystem)
                .with_parallel(true)
        )
        .add_stage(
            SystemStage::new("network")
                .with_system(NetworkSyncSystem)
                .with_parallel(false)
        )
        .add_stage(
            SystemStage::new("rendering")
                .with_system(RenderingSystem)
                .with_parallel(false)
        )
}
```

## 性能最適化テクニック

1. **システム実行の並列化** - 独立したシステムを並列実行
2. **エンティティのフィルタリング** - 関連コンポーネントを持つエンティティのみを処理
3. **システムの実行頻度調整** - 重要度に応じて実行頻度を変える
4. **バッチ処理** - 同種の処理をまとめて実行
5. **遅延処理** - 非クリティカルな処理を遅延させる

## コンポーネントとシステムの対応関係

| コンポーネント | 関連システム |
|--------------|------------|
| Position     | MovementSystem, PhysicsSystem, RenderingSystem |
| Velocity     | MovementSystem, PhysicsSystem |
| Sprite       | RenderingSystem |
| Animation    | AnimationSystem |
| Collider     | PhysicsSystem |
| PlayerControlled | InputSystem |
| AI           | AISystem |
| NetworkSync  | NetworkSyncSystem |

## システム特有のリソース

```rust
// レンダリングリソース
pub struct RenderingResource {
    pub sprite_sheet_cache: HashMap<String, HtmlImageElement>,
    pub z_layers: Vec<Vec<EntityId>>,
    pub view_width: u32,
    pub view_height: u32,
}

// カメラリソース
pub struct CameraResource {
    pub position: Position,
    pub zoom: f32,
    pub target_entity: Option<EntityId>,
    pub bounds: Option<(f32, f32, f32, f32)>,  // min_x, min_y, max_x, max_y
}

// 物理シミュレーションリソース
pub struct PhysicsResource {
    pub gravity: f32,
    pub collision_iterations: u32,
    pub velocity_iterations: u32,
}

// ゲーム状態リソース
pub struct GameStateResource {
    pub current_state: GameState,
    pub previous_state: Option<GameState>,
    pub transition_time: f32,
}

// ネットワークリソース
pub struct NetworkResource {
    pub client_id: String,
    pub server_time: f64,
    pub client_time: f64,
    pub rtt: f64,  // Round Trip Time
    pub time_sync_factor: f64,
}

// ローカルプレイヤーリソース
pub struct LocalPlayerResource {
    pub entity: EntityId,
    pub name: String,
    pub input_buffer: VecDeque<PlayerInput>,
}
``` 