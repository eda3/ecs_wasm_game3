# アーキテクチャ設計

## ECSアーキテクチャ概要

Entity-Component-System (ECS) アーキテクチャは、エンティティ、コンポーネント、システムの3つの主要な概念に基づいています。このアーキテクチャでは、データ（コンポーネント）とロジック（システム）を明確に分離し、柔軟性と高パフォーマンスを実現します。

### ECSの主要概念

- **Entity（エンティティ）**: ゲーム内のオブジェクトを表す単なる識別子（ID）
- **Component（コンポーネント）**: エンティティに関連付けられたデータ（位置、速度など）
- **System（システム）**: 特定のコンポーネントを持つエンティティに対して処理を行うロジック
- **World（ワールド）**: すべてのエンティティ、コンポーネント、システムを管理する中央リポジトリ
- **Resource（リソース）**: システム間で共有されるグローバルデータ

## 独自ECS実装の詳細設計

### エンティティ管理

```rust
/// エンティティの一意な識別子
pub type EntityId = uuid::Uuid;

/// エンティティの生成と削除を管理
pub struct EntityManager {
    entities: HashSet<EntityId>,
    pending_deletion: Vec<EntityId>,
}

impl EntityManager {
    /// 新しいエンティティを作成
    pub fn create_entity(&mut self) -> EntityId {
        let entity = uuid::Uuid::new_v4();
        self.entities.insert(entity);
        entity
    }
    
    /// エンティティを削除
    pub fn delete_entity(&mut self, entity: EntityId) {
        self.pending_deletion.push(entity);
    }
    
    /// 削除予定のエンティティを処理
    pub fn process_pending_deletions(&mut self) -> Vec<EntityId> {
        let deleted = self.pending_deletion.clone();
        for entity in &self.pending_deletion {
            self.entities.remove(entity);
        }
        self.pending_deletion.clear();
        deleted
    }
    
    /// すべてのエンティティを取得
    pub fn entities(&self) -> impl Iterator<Item = EntityId> + '_ {
        self.entities.iter().copied()
    }
}
```

### コンポーネント設計

```rust
/// すべてのコンポーネントが実装すべきトレイト
pub trait Component: 'static + Send + Sync + Clone + Default {}

/// コンポーネントの例
#[derive(Clone, Default)]
pub struct Position {
    pub x: f32,
    pub y: f32,
}
impl Component for Position {}

#[derive(Clone, Default)]
pub struct Velocity {
    pub x: f32,
    pub y: f32,
}
impl Component for Velocity {}

#[derive(Clone, Default)]
pub struct Sprite {
    pub image_id: String,
    pub width: f32,
    pub height: f32,
}
impl Component for Sprite {}
```

### コンポーネントストレージ

```rust
/// コンポーネントストレージの抽象トレイト
pub trait ComponentStorage {
    type Component: Component;
    
    fn insert(&mut self, entity: EntityId, component: Self::Component);
    fn remove(&mut self, entity: EntityId) -> Option<Self::Component>;
    fn get(&self, entity: EntityId) -> Option<&Self::Component>;
    fn get_mut(&mut self, entity: EntityId) -> Option<&mut Self::Component>;
    fn contains(&self, entity: EntityId) -> bool;
    fn clear(&mut self);
}

/// ハッシュマップベースのコンポーネントストレージ実装
pub struct HashMapStorage<T: Component> {
    data: HashMap<EntityId, T>,
}

impl<T: Component> ComponentStorage for HashMapStorage<T> {
    type Component = T;
    
    fn insert(&mut self, entity: EntityId, component: T) {
        self.data.insert(entity, component);
    }
    
    fn remove(&mut self, entity: EntityId) -> Option<T> {
        self.data.remove(&entity)
    }
    
    fn get(&self, entity: EntityId) -> Option<&T> {
        self.data.get(&entity)
    }
    
    fn get_mut(&mut self, entity: EntityId) -> Option<&mut T> {
        self.data.get_mut(&entity)
    }
    
    fn contains(&self, entity: EntityId) -> bool {
        self.data.contains_key(&entity)
    }
    
    fn clear(&mut self) {
        self.data.clear();
    }
}
```

### システム設計

```rust
/// システムトレイト
pub trait System {
    fn run(&mut self, world: &mut World, delta_time: f32);
}

/// 移動システムの例
pub struct MovementSystem;

impl System for MovementSystem {
    fn run(&mut self, world: &mut World, delta_time: f32) {
        // 位置と速度コンポーネントを持つエンティティを処理
        let entities: Vec<EntityId> = world.query::<(&Position, &Velocity)>().iter().collect();
        
        for entity in entities {
            // コンポーネントを安全に取得
            let velocity = world.get_component::<Velocity>(entity).unwrap();
            let mut position = world.get_component_mut::<Position>(entity).unwrap();
            
            // 位置を更新
            position.x += velocity.x * delta_time;
            position.y += velocity.y * delta_time;
        }
    }
}
```

### ワールドとリソース

```rust
use std::any::{Any, TypeId};

/// ゲームワールド - すべてのエンティティ、コンポーネント、リソースを管理
pub struct World {
    entity_manager: EntityManager,
    component_storages: HashMap<TypeId, Box<dyn Any + Send + Sync>>,
    resources: HashMap<TypeId, Box<dyn Any + Send + Sync>>,
}

impl World {
    pub fn new() -> Self {
        Self {
            entity_manager: EntityManager::new(),
            component_storages: HashMap::new(),
            resources: HashMap::new(),
        }
    }
    
    /// エンティティを作成
    pub fn create_entity(&mut self) -> EntityId {
        self.entity_manager.create_entity()
    }
    
    /// エンティティを削除
    pub fn delete_entity(&mut self, entity: EntityId) {
        self.entity_manager.delete_entity(entity);
        // 関連コンポーネントも削除
    }
    
    /// コンポーネントを追加
    pub fn add_component<T: Component>(&mut self, entity: EntityId, component: T) {
        let type_id = TypeId::of::<T>();
        
        // 必要なら新しいストレージを作成
        if !self.component_storages.contains_key(&type_id) {
            self.component_storages.insert(type_id, Box::new(HashMapStorage::<T>::new()));
        }
        
        // コンポーネントをストレージに追加
        let storage = self.component_storages.get_mut(&type_id)
            .unwrap()
            .downcast_mut::<HashMapStorage<T>>()
            .unwrap();
            
        storage.insert(entity, component);
    }
    
    /// コンポーネントを取得
    pub fn get_component<T: Component>(&self, entity: EntityId) -> Option<&T> {
        let type_id = TypeId::of::<T>();
        
        self.component_storages.get(&type_id)
            .and_then(|storage| storage.downcast_ref::<HashMapStorage<T>>())
            .and_then(|storage| storage.get(entity))
    }
    
    /// コンポーネントを可変参照で取得
    pub fn get_component_mut<T: Component>(&mut self, entity: EntityId) -> Option<&mut T> {
        let type_id = TypeId::of::<T>();
        
        self.component_storages.get_mut(&type_id)
            .and_then(|storage| storage.downcast_mut::<HashMapStorage<T>>())
            .and_then(|storage| storage.get_mut(entity))
    }
    
    /// リソースを追加または更新
    pub fn insert_resource<T: 'static + Send + Sync>(&mut self, resource: T) {
        let type_id = TypeId::of::<T>();
        self.resources.insert(type_id, Box::new(resource));
    }
    
    /// リソースを取得
    pub fn get_resource<T: 'static + Send + Sync>(&self) -> Option<&T> {
        let type_id = TypeId::of::<T>();
        self.resources.get(&type_id)
            .and_then(|res| res.downcast_ref::<T>())
    }
    
    /// リソースを可変参照で取得
    pub fn get_resource_mut<T: 'static + Send + Sync>(&mut self) -> Option<&mut T> {
        let type_id = TypeId::of::<T>();
        self.resources.get_mut(&type_id)
            .and_then(|res| res.downcast_mut::<T>())
    }
    
    /// エンティティのクエリを実行
    pub fn query<Q: Query>(&self) -> QueryResult<Q> {
        Q::query(self)
    }
}
```

### クエリシステム

```rust
/// クエリトレイト - 複数コンポーネントの組み合わせを抽象化
pub trait Query {
    type Item;
    fn query(world: &World) -> QueryResult<Self>;
}

/// クエリ結果
pub struct QueryResult<Q: Query> {
    entities: Vec<(EntityId, Q::Item)>,
}

impl<Q: Query> QueryResult<Q> {
    pub fn iter(&self) -> impl Iterator<Item = EntityId> + '_ {
        self.entities.iter().map(|(entity, _)| *entity)
    }
    
    pub fn iter_with_components(&self) -> impl Iterator<Item = &(EntityId, Q::Item)> {
        self.entities.iter()
    }
}

/// 単一コンポーネントクエリの実装
impl<'a, T: Component> Query for &'a T {
    type Item = &'a T;
    
    fn query(world: &World) -> QueryResult<Self> {
        let type_id = TypeId::of::<T>();
        
        let mut results = Vec::new();
        
        if let Some(storage) = world.component_storages.get(&type_id)
            .and_then(|s| s.downcast_ref::<HashMapStorage<T>>()) {
            
            for entity in world.entity_manager.entities() {
                if let Some(component) = storage.get(entity) {
                    // 安全でない参照変換（実際の実装ではライフタイム管理が必要）
                    let component_ref = unsafe { std::mem::transmute::<&T, &'a T>(component) };
                    results.push((entity, component_ref));
                }
            }
        }
        
        QueryResult { entities: results }
    }
}

/// 複数コンポーネントのタプルクエリ実装（例: (&Position, &Velocity)）
impl<'a, A: Component, B: Component> Query for (&'a A, &'a B) {
    type Item = (&'a A, &'a B);
    
    fn query(world: &World) -> QueryResult<Self> {
        let type_id_a = TypeId::of::<A>();
        let type_id_b = TypeId::of::<B>();
        
        let mut results = Vec::new();
        
        if let (Some(storage_a), Some(storage_b)) = (
            world.component_storages.get(&type_id_a).and_then(|s| s.downcast_ref::<HashMapStorage<A>>()),
            world.component_storages.get(&type_id_b).and_then(|s| s.downcast_ref::<HashMapStorage<B>>()),
        ) {
            for entity in world.entity_manager.entities() {
                if let (Some(component_a), Some(component_b)) = (storage_a.get(entity), storage_b.get(entity)) {
                    // 安全でない参照変換
                    let a_ref = unsafe { std::mem::transmute::<&A, &'a A>(component_a) };
                    let b_ref = unsafe { std::mem::transmute::<&B, &'a B>(component_b) };
                    
                    results.push((entity, (a_ref, b_ref)));
                }
            }
        }
        
        QueryResult { entities: results }
    }
}
```

## ECSパフォーマンス最適化

### 1. アーキタイプベースのストレージ（発展段階）

```rust
/// アーキタイプ - 同じコンポーネントの組み合わせを持つエンティティのグループ
struct Archetype {
    entities: Vec<EntityId>,
    component_types: Vec<TypeId>,
    component_data: HashMap<TypeId, Box<dyn ComponentArray>>,
}

/// コンポーネント配列のトレイト
trait ComponentArray: Any + Send + Sync {
    fn push_empty(&mut self);
    fn remove(&mut self, index: usize);
    fn clear(&mut self);
}

/// 特定タイプのコンポーネント配列
struct TypedComponentArray<T: Component> {
    data: Vec<T>,
}

impl<T: Component> ComponentArray for TypedComponentArray<T> {
    fn push_empty(&mut self) {
        self.data.push(T::default());
    }
    
    fn remove(&mut self, index: usize) {
        if index < self.data.len() {
            self.data.swap_remove(index);
        }
    }
    
    fn clear(&mut self) {
        self.data.clear();
    }
}
```

### 2. スパースセット

```rust
/// スパースセットベースのコンポーネントストレージ
pub struct SparseSetStorage<T: Component> {
    sparse: HashMap<EntityId, usize>,  // エンティティIDからインデックスへのマップ
    dense: Vec<(EntityId, T)>,         // 密集配列
}

impl<T: Component> ComponentStorage for SparseSetStorage<T> {
    type Component = T;
    
    fn insert(&mut self, entity: EntityId, component: T) {
        if let Some(idx) = self.sparse.get(&entity) {
            // 既存エントリを更新
            self.dense[*idx].1 = component;
        } else {
            // 新規エントリを追加
            let idx = self.dense.len();
            self.dense.push((entity, component));
            self.sparse.insert(entity, idx);
        }
    }
    
    fn remove(&mut self, entity: EntityId) -> Option<T> {
        if let Some(idx) = self.sparse.remove(&entity) {
            // 最後の要素と交換して削除
            let last_idx = self.dense.len() - 1;
            if idx != last_idx {
                let last_entity = self.dense[last_idx].0;
                self.dense.swap(idx, last_idx);
                self.sparse.insert(last_entity, idx);
            }
            let (_, component) = self.dense.pop().unwrap();
            Some(component)
        } else {
            None
        }
    }
    
    // 他のメソッド実装...
}
```

### 3. ビット配列によるエンティティフィルタリング

```rust
/// コンポーネントマスク - どのコンポーネントを持っているかを表すビットセット
pub struct ComponentMask {
    bits: Vec<u64>,
}

impl ComponentMask {
    pub fn new() -> Self {
        Self { bits: vec![0; 4] }  // 256ビット
    }
    
    pub fn set_bit(&mut self, bit: usize, value: bool) {
        let idx = bit / 64;
        let bit_pos = bit % 64;
        
        if idx >= self.bits.len() {
            self.bits.resize(idx + 1, 0);
        }
        
        if value {
            self.bits[idx] |= 1 << bit_pos;
        } else {
            self.bits[idx] &= !(1 << bit_pos);
        }
    }
    
    pub fn matches(&self, other: &ComponentMask) -> bool {
        let len = std::cmp::min(self.bits.len(), other.bits.len());
        
        for i in 0..len {
            if (self.bits[i] & other.bits[i]) != self.bits[i] {
                return false;
            }
        }
        
        if self.bits.len() > len {
            for i in len..self.bits.len() {
                if self.bits[i] != 0 {
                    return false;
                }
            }
        }
        
        true
    }
}
```

## リソース管理

```rust
/// グローバルまたはシングルトンリソースを表すマーカートレイト
pub trait Resource: 'static + Send + Sync {}

/// タイムリソースの例
#[derive(Default)]
pub struct TimeResource {
    pub delta_time: f32,
    pub total_time: f32,
    pub frame_count: u64,
}
impl Resource for TimeResource {}

/// 入力状態リソースの例
#[derive(Default)]
pub struct InputResource {
    pub keyboard: HashMap<u32, bool>,  // キーコード -> 押されているか
    pub mouse_position: (f32, f32),
    pub mouse_buttons: [bool; 3],      // 左、中、右ボタン
}
impl Resource for InputResource {}
```

## スケジューラ設計

```rust
/// システムステージ - 実行のまとまり
pub struct SystemStage {
    name: String,
    systems: Vec<Box<dyn System>>,
    parallel: bool,
}

impl SystemStage {
    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_string(),
            systems: Vec::new(),
            parallel: false,
        }
    }
    
    pub fn with_system<S: System + 'static>(mut self, system: S) -> Self {
        self.systems.push(Box::new(system));
        self
    }
    
    pub fn with_parallel(mut self, parallel: bool) -> Self {
        self.parallel = parallel;
        self
    }
    
    pub fn run(&mut self, world: &mut World, delta_time: f32) {
        if self.parallel {
            // 並列実行（実際の実装では複雑なスレッド管理が必要）
            self.run_parallel(world, delta_time);
        } else {
            // 順次実行
            for system in &mut self.systems {
                system.run(world, delta_time);
            }
        }
    }
    
    fn run_parallel(&mut self, world: &mut World, delta_time: f32) {
        // 簡略化された並列実行の例（実際には適切なスレッド安全性が必要）
        // このコードはデモンストレーション目的であり、実際の実装では
        // 並行処理のためのより複雑なアプローチが必要です
        
        // ここで並列処理のロジックを実装
    }
}

/// スケジューラ - 複数のステージを順次実行
pub struct Schedule {
    stages: Vec<SystemStage>,
}

impl Schedule {
    pub fn new() -> Self {
        Self { stages: Vec::new() }
    }
    
    pub fn add_stage(mut self, stage: SystemStage) -> Self {
        self.stages.push(stage);
        self
    }
    
    pub fn run(&mut self, world: &mut World, delta_time: f32) {
        for stage in &mut self.stages {
            stage.run(world, delta_time);
        }
    }
}
```

## メモリ最適化戦略

1. **オブジェクトプーリング**: エンティティとコンポーネントの再利用
2. **アーキタイプベースのレイアウト**: データの局所性を高める
3. **SoA (Structure of Arrays)**: キャッシュ効率の向上
4. **ビットセットとマスク**: 高速な比較とフィルタリング
5. **遅延削除**: エンティティとコンポーネントの削除を一括処理

## イベントシステム

```rust
/// イベントの基本トレイト
pub trait Event: 'static + Send + Sync + Clone {}

/// イベントキュー
pub struct EventQueue<E: Event> {
    current_events: Vec<E>,
    next_events: Vec<E>,
}

impl<E: Event> EventQueue<E> {
    pub fn new() -> Self {
        Self {
            current_events: Vec::new(),
            next_events: Vec::new(),
        }
    }
    
    pub fn send(&mut self, event: E) {
        self.next_events.push(event);
    }
    
    pub fn events(&self) -> impl Iterator<Item = &E> {
        self.current_events.iter()
    }
    
    pub fn update(&mut self) {
        std::mem::swap(&mut self.current_events, &mut self.next_events);
        self.next_events.clear();
    }
}

/// イベントの例
#[derive(Clone)]
pub struct CollisionEvent {
    pub entity_a: EntityId,
    pub entity_b: EntityId,
    pub point: (f32, f32),
}
impl Event for CollisionEvent {}
```

## パフォーマンステスト

```rust
/// ECSのパフォーマンスをベンチマークするユーティリティ
pub struct EcsBenchmark {
    entity_count: usize,
    component_count: usize,
    system_count: usize,
    iterations: usize,
}

impl EcsBenchmark {
    pub fn new(entity_count: usize, component_count: usize, system_count: usize, iterations: usize) -> Self {
        Self {
            entity_count,
            component_count,
            system_count,
            iterations,
        }
    }
    
    pub fn run(&self) -> BenchmarkResults {
        // 1. ワールドを初期化
        let mut world = World::new();
        
        // 2. エンティティとコンポーネントを生成
        self.setup_entities(&mut world);
        
        // 3. システムを設定
        let mut schedule = self.setup_systems();
        
        // 4. ベンチマーク実行
        let start_time = js_sys::Date::now();
        
        for _ in 0..self.iterations {
            schedule.run(&mut world, 0.016);  // ~60FPS
        }
        
        let end_time = js_sys::Date::now();
        let duration_ms = end_time - start_time;
        
        BenchmarkResults {
            entity_count: self.entity_count,
            component_count: self.component_count,
            system_count: self.system_count,
            iterations: self.iterations,
            duration_ms,
            avg_frame_time: duration_ms / (self.iterations as f64),
        }
    }
    
    // その他のセットアップメソッド...
}
``` 