# ECS WebAssembly Game コード品質ガイドライン

## 1. コードスタイル

### 1.1 命名規則
- **構造体**: PascalCase
  ```rust
  struct PlayerEntity;
  struct GameState;
  ```
- **トレイト**: PascalCase
  ```rust
  trait Component;
  trait System;
  ```
- **関数**: snake_case
  ```rust
  fn create_entity();
  fn update_game_state();
  ```
- **変数**: snake_case
  ```rust
  let entity_id;
  let game_state;
  ```
- **定数**: SCREAMING_SNAKE_CASE
  ```rust
  const MAX_ENTITIES: usize = 1000;
  const TARGET_FPS: u32 = 60;
  ```

### 1.2 フォーマット
- インデント: 4スペース
- 行の長さ: 最大100文字
- トレイト境界: 複数行で記述
  ```rust
  impl<T> System for MySystem<T>
  where
      T: Component + Send + Sync,
  {
      // ...
  }
  ```

### 1.3 ドキュメント
- モジュールレベル: `//!` を使用
  ```rust
  //! ゲームエンティティモジュール
  //! 
  //! ゲーム固有のエンティティとコンポーネントを実装します。
  ```
- 構造体/トレイト: `///` を使用
  ```rust
  /// プレイヤーエンティティ
  /// 
  /// プレイヤーキャラクターを表すエンティティです。
  pub struct Player;
  ```
- 関数: `///` を使用
  ```rust
  /// 新しいプレイヤーエンティティを作成します。
  /// 
  /// # 引数
  /// 
  /// * `world` - エンティティを作成するワールド
  /// 
  /// # 戻り値
  /// 
  /// 作成されたエンティティ、またはエラー
  pub fn create(world: &mut World) -> Result<Entity, JsValue>;
  ```

## 2. エラーハンドリング

### 2.1 エラー型
- カスタムエラー型の定義
  ```rust
  #[derive(Debug)]
  pub struct GameError {
      message: String,
      source: Option<Box<dyn std::error::Error>>,
  }
  ```

### 2.2 エラー処理
- `Result`型の使用
  ```rust
  pub fn load_resource(path: &str) -> Result<Resource, GameError>;
  ```
- エラーの伝播
  ```rust
  fn process_input() -> Result<(), GameError> {
      let input = read_input()?;
      validate_input(&input)?;
      Ok(())
  }
  ```

### 2.3 Option型の扱い
- `unwrap_or`を使用したデフォルト値の設定
  ```rust
  // Option<f32>をf32に安全に変換
  position.z.unwrap_or(0.0);
  ```
- パターンマッチングを使用した安全な処理
  ```rust
  match optional_value {
      Some(value) => process_value(value),
      None => handle_missing_value(),
  }
  ```
- メソッド呼び出し時のOption型の適切な処理
  ```rust
  // 良い例: Optionの可能性を考慮したコード
  snapshot.with_position([position.x, position.y, position.z.unwrap_or(0.0)]);
  
  // 避けるべき例: 不用意なunwrap
  snapshot.with_position([position.x, position.y, position.z.unwrap()]); // パニックの危険性
  ```
- 型の一貫性の確保
  ```rust
  // 構造体の定義で明示的にOptionであることを宣言
  pub struct PositionComponent {
      pub x: f32,
      pub y: f32,
      pub z: Option<f32>, // 必須でない値はOptionで表現
  }
  ```

### 2.4 型変換のベストプラクティス
- 明示的な型変換を使用
  ```rust
  // u8からu32への安全な変換
  let key_code: u32 = mouse_button.into();
  
  // 数値型の変換
  let float_value: f32 = integer_value as f32;
  ```
- TryIntoトレイトを使用した安全な変換
  ```rust
  // 失敗する可能性のある変換（例: u64からu32への変換）
  let smaller_value: u32 = larger_value.try_into().unwrap_or(0);
  ```
- メソッド呼び出し時の型変換
  ```rust
  // 良い例: 型変換を明示的に行う
  .bind_key("attack", MOUSE_LEFT.into());  // u8からu32へ
  
  // 避けるべき例: 暗黙的な型変換に頼る
  .bind_key("attack", MOUSE_LEFT);  // 型が一致しない
  ```
- 文字列からの変換
  ```rust
  // 文字列からの数値変換
  let value = str_value.parse::<i32>().unwrap_or(0);
  ```

### 2.5 所有権と借用のパターン
- 参照の衝突を避ける
  ```rust
  // 問題のあるコード: 同じオブジェクトを不変参照と可変参照で同時に使用
  if let Some(component) = world.get_component::<Component>(entity) {
      for item in &component.items {
          // エラー: worldはすでに不変参照されている
          handler(entity, world, item)?;
      }
  }
  
  // 改善案1: 必要なデータを事前に収集
  let actions_to_execute = entities
      .iter()
      .filter_map(|entity| {
          world.get_component::<Component>(*entity).map(|component| 
              (entity, component.get_actions())
          )
      })
      .collect::<Vec<_>>();
  
  // 収集後に処理を実行（所有権の衝突なし）
  for (entity, actions) in actions_to_execute {
      for action in actions {
          handler(*entity, world, action)?;
      }
  }
  ```

- クロージャと所有権
  ```rust
  // 良い例: moveキーワードで所有権を明示的に移動
  let processor = move |data| {
      // dataの所有権を取得
      process_owned_data(data);
  };
  
  // 良い例: 参照のみを使用
  let reader = |data: &Data| {
      // dataの参照のみを使用
      read_data(data);
  };
  ```

- RefCellによる内部可変性
  ```rust
  use std::cell::RefCell;
  
  // 不変参照しか持てない状況で可変性が必要な場合
  struct Component {
      data: RefCell<Vec<String>>,
  }
  
  impl Component {
      fn add_item(&self, item: String) {
          // 不変参照を持ちながらも内部データを変更可能
          self.data.borrow_mut().push(item);
      }
  }
  ```

### 2.6 構造体初期化のベストプラクティス
- 全ての必須パラメータを渡す
  ```rust
  // 良い例: すべての必須パラメータを渡している
  let snapshot = EntitySnapshot::new(entity_id, timestamp);
  
  // 避けるべき例: 必須パラメータを省略し、後から設定している
  let mut snapshot = EntitySnapshot::new(entity_id); // タイムスタンプ引数が不足
  snapshot.timestamp = timestamp; // 後から設定
  ```

- コンストラクタの設計と利用
  ```rust
  // 良い例: 必須パラメータを強制する設計
  impl EntitySnapshot {
      pub fn new(entity_id: u32, timestamp: f64) -> Self {
          Self {
              entity_id,
              components: HashMap::new(),
              timestamp,
              owner_id: None,
          }
      }
  }
  
  // コンストラクタを正しく呼び出し
  let snapshot = EntitySnapshot::new(entity_id, timestamp);
  ```

- ビルダーパターンの活用
  ```rust
  // オプションパラメータが多い場合はビルダーパターンを使用
  let snapshot = EntitySnapshot::new(entity_id, timestamp)
      .with_component("position", position_data)
      .with_owner(player_id);
  ```

- 構造体を返す関数の設計
  ```rust
  // 良い例: 構造体を返す関数は意図を明確にする
  fn create_entity_snapshot(&self, world: &World, entity: Entity, timestamp: f64) -> EntitySnapshot {
      let mut snapshot = EntitySnapshot::new(entity.id().0, timestamp);
      // ...
      snapshot
  }
  ```

### 2.7 不透明な型の安全な処理

- プライベートフィールドへの直接アクセスを避ける
  ```rust
  // 問題のあるコード：プライベートフィールドに直接アクセス
  let id_value = entity.id().0; // エラー：フィールド `0` は private
  
  // 良い例：公開APIを通じてアクセス
  let id_value = entity.index();
  ```

- 文字列からの安全な変換
  ```rust
  // 良い例：安全に変換するヘルパーメソッドの実装
  impl Entity {
      pub fn index(&self) -> u64 {
          match format!("{}", self.id).strip_prefix("Entity(").and_then(|s| s.strip_suffix(")")) {
              Some(id_str) => id_str.parse::<u64>().unwrap_or(0),
              None => 0,
          }
      }
  }
  ```

- 型変換時のエラーハンドリング
  ```rust
  // 整数型間の安全な変換
  let entity_id_u32 = entity.index() as u32; // u64からu32への変換（値が大きい場合は切り捨て）
  
  // より安全な変換（オーバーフローチェック付き）
  let entity_id_u32 = u32::try_from(entity.index()).unwrap_or(0);
  ```

- 不透明な型の一貫した使用
  ```rust
  // 良い例：EntityIdの内部実装に依存しない
  let entity_snapshot = EntitySnapshot::new(entity.index() as u32, timestamp);
  
  // 避けるべき例：内部表現に直接依存
  let entity_snapshot = EntitySnapshot::new(entity.id().0 as u32, timestamp);
  ```

### 2.8 Option型の安全な扱い方

- 直接操作の回避
  ```rust
  // 問題のあるコード：Option<f32>に直接演算を適用
  position.z += vel_z * delta_time; // エラー：Option<f32>に+=演算子は適用できない
  
  // 良い例：mapメソッドを使用して内部の値を安全に変更
  position.z = position.z.map(|z| z + vel_z * delta_time);
  ```

- `if let`パターンを使用した安全な比較
  ```rust
  // 問題のあるコード：Option<f32>を直接比較
  if position.z > 0.0 { ... } // エラー：Option<f32>と数値を直接比較できない
  
  // 良い例：if letを使用して値を取り出してから比較
  if let Some(z) = position.z {
      if z > 0.0 {
          // ...
      }
  }
  ```

- `map_or`を使用した条件処理とデフォルト値
  ```rust
  // 良い例：値がない場合のデフォルト処理と値がある場合の条件処理を一度に
  if position.z.map_or(true, |z| z <= 0.01) {
      // zがNoneの場合はtrue、Someの場合は0.01以下かどうかをチェック
      // ...
  }
  ```

- `unwrap_or`を使用したデフォルト値の設定
  ```rust
  // 良い例：Noneの場合のデフォルト値を指定
  let z_value = position.z.unwrap_or(0.0);
  
  // 計算のためにデフォルト値を使用する
  let height = position.z.unwrap_or(0.0) * scale_factor;
  ```

- `and_then`によるチェイン処理
  ```rust
  // 良い例：複数のOption処理をチェイン
  let jump_velocity = position.z
      .and_then(|z| if z < 0.01 { Some(z) } else { None })
      .map(|_| 10.0);
  ```

- 値の設定時はSomeでラップ
  ```rust
  // 問題のあるコード：生の値をOptionに代入
  position.z = 0.0; // エラー：f32とOption<f32>の型が不一致
  
  // 良い例：Someでラップして設定
  position.z = Some(0.0);
  ```

## 3. テスト

### 3.1 ユニットテスト
- テストモジュールの配置
  ```rust
  #[cfg(test)]
  mod tests {
      use super::*;
      use wasm_bindgen_test::*;

      #[wasm_bindgen_test]
      fn test_entity_creation() {
          // ...
      }
  }
  ```

### 3.2 テストカバレッジ
- 主要な機能のテスト
- エッジケースのテスト
- エラーパスのテスト

## 4. パフォーマンス

### 4.1 メモリ管理
- 適切なデータ構造の選択
  ```rust
  // 高速なルックアップが必要な場合
  use std::collections::HashMap;
  
  // 連続したメモリが必要な場合
  use std::vec::Vec;
  ```
- メモリリークの防止
  ```rust
  impl Drop for Resource {
      fn drop(&mut self) {
          // リソースの解放
      }
  }
  ```

### 4.2 所有権とメソッドチェーン
- メソッドチェーンでの所有権移動に注意
  ```rust
  // 問題のあるコード: with_positionメソッドが所有権を消費する場合
  snapshot.with_position([x, y, z]); // snapshotの所有権が移動する
  snapshot.with_velocity([vx, vy, vz]); // エラー: 既に移動したsnapshotを使用

  // 改善策1: 直接フィールドに代入
  let pos = [x, y, z];
  snapshot.position = Some(pos);
  snapshot.velocity = Some([vx, vy, vz]);

  // 改善策2: メソッドが&mut selfを取るように設計
  snapshot.set_position([x, y, z]); // 所有権を移動しない
  snapshot.set_velocity([vx, vy, vz]); // OK
  ```

- EntityIdのような不透明な型を安全に扱う
  ```rust
  // EntityIdをu64に安全に変換
  let entity_id = entity.id();
  let id_value = match format!("{}", entity_id).strip_prefix("Entity(").and_then(|s| s.strip_suffix(")")) {
      Some(id_str) => id_str.parse::<u64>().unwrap_or(0),
      None => 0,
  };
  ```

- 値の変換時は適切なエラーハンドリング
  ```rust
  // u64からu32への安全な変換
  let u32_value = u64_value.try_into().unwrap_or(0);
  ```

### 4.3 最適化
- プロファイリングの実施
- ボトルネックの特定と改善
- キャッシュの活用

## 5. セキュリティ

### 5.1 入力検証
- ユーザー入力の検証
  ```rust
  fn validate_input(input: &str) -> Result<(), ValidationError> {
      if input.is_empty() {
          return Err(ValidationError::EmptyInput);
      }
      // ...
  }
  ```

## 6. トラブルシューティング

### 6.1 物理エンジン関連の修正
- `PhysicsEntity` には `Clone` トレイトを実装済み (#[derive(Clone)]を追加済み)
- `SpatialGrid` と `CollisionFilter` にも `Clone` トレイトを実装済み (#[derive(Clone)]を追加済み)
- `SpatialGrid` の `add_entity` メソッドは、正しくは `insert_entity` であることに注意して修正済み
- `CollisionFilter` の `set_entity_category` および `set_entity_mask` メソッドは、正しくはそれぞれ `set_category` および `set_mask` であり修正済み
- `PhysicsStep.update()` は `(usize, f64)` のタプルを返すため、それに応じた処理が必要 (タプルからステップ数を取り出して処理するよう修正済み)
- 衝突ペア（collision pairs）はタプル `(u32, u32)` であり、これらの値は `pair.0` および `pair.1` としてアクセスするよう修正済み
- `generate_collision_pairs` 関数の呼び出し時、`collision_filter` 引数は `Option<CollisionFilter>` 型として渡す必要があるため、`&Some(collision_filter.clone())` として渡すよう修正済み
- 衝突解決時に同時に2つのエンティティを可変借用できないため、エンティティを順番に処理するように修正済み

### 6.2 ECS関連
- `query` メソッドと関連機能の実装には注意が必要
- コンポーネントとシステムの相互作用では、適切な型の使用を確認すべき

## 7. WebAssembly対応

WebAssembly環境では、通常のRustアプリケーションとは異なる制約や考慮事項があります。

### 7.1 スレッドセーフティ制約の緩和

- WebAssemblyはシングルスレッド環境で動作するため、`Send`と`Sync`トレイトの要件を適切に緩和する
  ```rust
  // 通常環境とWasm環境で異なる実装を提供
  #[cfg(not(target_arch = "wasm32"))]
  pub trait Resource: 'static + Send + Sync + Any {
      // ...
  }

  #[cfg(target_arch = "wasm32")]
  pub trait Resource: 'static + Any {
      // ...
  }
  ```

### 7.2 JavaScriptとの相互運用

- JavaScriptオブジェクトを扱う際は、所有権の移動に注意
  ```rust
  // JavaScriptの値はコピーではなく参照として扱う
  let canvas_context = document
      .get_element_by_id("game-canvas")?
      .dyn_into::<HtmlCanvasElement>()?
      .get_context("2d")?
      .unwrap()
      .dyn_into::<CanvasRenderingContext2d>()?;
  ```

- エラーハンドリングにおいては`JsValue`を適切に変換
  ```rust
  pub fn init() -> Result<(), JsValue> {
      // エラーを適切にJsValueに変換
      let config = get_config().map_err(|e| JsValue::from_str(&e.to_string()))?;
      Ok(())
  }
  ```

### 7.3 条件付きコンパイル

- 環境に応じた条件付きコンパイルを活用
  ```rust
  // WebAssembly環境専用の実装
  #[cfg(target_arch = "wasm32")]
  fn init_web_api() -> Result<(), JsValue> {
      // Webブラウザ専用の初期化コード
  }

  // 非WebAssembly環境専用の実装
  #[cfg(not(target_arch = "wasm32"))]
  fn init_native_api() -> Result<(), String> {
      // ネイティブ環境専用の初期化コード
  }
  ```

### 7.4 メモリ管理

- WebAssembly環境ではメモリ制約に注意し、大きなメモリアロケーションを避ける
  ```rust
  // 大きな配列を作る代わりにイテレータを使用
  fn process_large_data() {
      // 悪い例: 大きな配列をメモリに保持
      // let large_array = vec![0; 1_000_000];
      
      // 良い例: イテレータを使用して少しずつ処理
      (0..1_000_000).map(|i| i * 2).for_each(|value| {
          process_value(value);
      });
  }
  ```