# ECS WebAssembly Game コード品質ガイドライン

## 1. コードスタイル

### 1.1 命名規則
- **構造体**: PascalCase
  ```rust
  struct PlayerEntity;
  struct GameState;
  ```
- **トレイト**: PascalCase
  ```rust
  trait Component;
  trait System;
  ```
- **関数**: snake_case
  ```rust
  fn create_entity();
  fn update_game_state();
  ```
- **変数**: snake_case
  ```rust
  let entity_id;
  let game_state;
  ```
- **定数**: SCREAMING_SNAKE_CASE
  ```rust
  const MAX_ENTITIES: usize = 1000;
  const TARGET_FPS: u32 = 60;
  ```

### 1.2 フォーマット
- インデント: 4スペース
- 行の長さ: 最大100文字
- トレイト境界: 複数行で記述
  ```rust
  impl<T> System for MySystem<T>
  where
      T: Component + Send + Sync,
  {
      // ...
  }
  ```

### 1.3 ドキュメント
- モジュールレベル: `//!` を使用
  ```rust
  //! ゲームエンティティモジュール
  //! 
  //! ゲーム固有のエンティティとコンポーネントを実装します。
  ```
- 構造体/トレイト: `///` を使用
  ```rust
  /// プレイヤーエンティティ
  /// 
  /// プレイヤーキャラクターを表すエンティティです。
  pub struct Player;
  ```
- 関数: `///` を使用
  ```rust
  /// 新しいプレイヤーエンティティを作成します。
  /// 
  /// # 引数
  /// 
  /// * `world` - エンティティを作成するワールド
  /// 
  /// # 戻り値
  /// 
  /// 作成されたエンティティ、またはエラー
  pub fn create(world: &mut World) -> Result<Entity, JsValue>;
  ```

## 2. エラーハンドリング

### 2.1 エラー型
- カスタムエラー型の定義
  ```rust
  #[derive(Debug)]
  pub struct GameError {
      message: String,
      source: Option<Box<dyn std::error::Error>>,
  }
  ```

### 2.2 エラー処理
- `Result`型の使用
  ```rust
  pub fn load_resource(path: &str) -> Result<Resource, GameError>;
  ```
- エラーの伝播
  ```rust
  fn process_input() -> Result<(), GameError> {
      let input = read_input()?;
      validate_input(&input)?;
      Ok(())
  }
  ```

### 2.3 Option型の扱い
- `unwrap_or`を使用したデフォルト値の設定
  ```rust
  // Option<f32>をf32に安全に変換
  position.z.unwrap_or(0.0);
  ```
- パターンマッチングを使用した安全な処理
  ```rust
  match optional_value {
      Some(value) => process_value(value),
      None => handle_missing_value(),
  }
  ```
- メソッド呼び出し時のOption型の適切な処理
  ```rust
  // 良い例: Optionの可能性を考慮したコード
  snapshot.with_position([position.x, position.y, position.z.unwrap_or(0.0)]);
  
  // 避けるべき例: 不用意なunwrap
  snapshot.with_position([position.x, position.y, position.z.unwrap()]); // パニックの危険性
  ```
- 型の一貫性の確保
  ```rust
  // 構造体の定義で明示的にOptionであることを宣言
  pub struct PositionComponent {
      pub x: f32,
      pub y: f32,
      pub z: Option<f32>, // 必須でない値はOptionで表現
  }
  ```

### 2.4 型変換のベストプラクティス
- 明示的な型変換を使用
  ```rust
  // u8からu32への安全な変換
  let key_code: u32 = mouse_button.into();
  
  // 数値型の変換
  let float_value: f32 = integer_value as f32;
  ```
- TryIntoトレイトを使用した安全な変換
  ```rust
  // 失敗する可能性のある変換（例: u64からu32への変換）
  let smaller_value: u32 = larger_value.try_into().unwrap_or(0);
  ```
- メソッド呼び出し時の型変換
  ```rust
  // 良い例: 型変換を明示的に行う
  .bind_key("attack", MOUSE_LEFT.into());  // u8からu32へ
  
  // 避けるべき例: 暗黙的な型変換に頼る
  .bind_key("attack", MOUSE_LEFT);  // 型が一致しない
  ```
- 文字列からの変換
  ```rust
  // 文字列からの数値変換
  let value = str_value.parse::<i32>().unwrap_or(0);
  ```

## 3. テスト

### 3.1 ユニットテスト
- テストモジュールの配置
  ```rust
  #[cfg(test)]
  mod tests {
      use super::*;
      use wasm_bindgen_test::*;

      #[wasm_bindgen_test]
      fn test_entity_creation() {
          // ...
      }
  }
  ```

### 3.2 テストカバレッジ
- 主要な機能のテスト
- エッジケースのテスト
- エラーパスのテスト

## 4. パフォーマンス

### 4.1 メモリ管理
- 適切なデータ構造の選択
  ```rust
  // 高速なルックアップが必要な場合
  use std::collections::HashMap;
  
  // 連続したメモリが必要な場合
  use std::vec::Vec;
  ```
- メモリリークの防止
  ```rust
  impl Drop for Resource {
      fn drop(&mut self) {
          // リソースの解放
      }
  }
  ```

### 4.2 所有権とメソッドチェーン
- メソッドチェーンでの所有権移動に注意
  ```rust
  // 問題のあるコード: with_positionメソッドが所有権を消費する場合
  snapshot.with_position([x, y, z]); // snapshotの所有権が移動する
  snapshot.with_velocity([vx, vy, vz]); // エラー: 既に移動したsnapshotを使用

  // 改善策1: 直接フィールドに代入
  let pos = [x, y, z];
  snapshot.position = Some(pos);
  snapshot.velocity = Some([vx, vy, vz]);

  // 改善策2: メソッドが&mut selfを取るように設計
  snapshot.set_position([x, y, z]); // 所有権を移動しない
  snapshot.set_velocity([vx, vy, vz]); // OK
  ```

- EntityIdのような不透明な型を安全に扱う
  ```rust
  // EntityIdをu64に安全に変換
  let entity_id = entity.id();
  let id_value = match format!("{}", entity_id).strip_prefix("Entity(").and_then(|s| s.strip_suffix(")")) {
      Some(id_str) => id_str.parse::<u64>().unwrap_or(0),
      None => 0,
  };
  ```

- 値の変換時は適切なエラーハンドリング
  ```rust
  // u64からu32への安全な変換
  let u32_value = u64_value.try_into().unwrap_or(0);
  ```

### 4.3 最適化
- プロファイリングの実施
- ボトルネックの特定と改善
- キャッシュの活用

## 5. セキュリティ

### 5.1 入力検証
- ユーザー入力の検証
  ```rust
  fn validate_input(input: &str) -> Result<(), ValidationError> {
      if input.is_empty() {
          return Err(ValidationError::EmptyInput);
      }
      // ...
  }
  ```

### 5.2 データ保護
- 機密データの暗号化
- アクセス制御の実装

## 6. 保守性

### 6.1 モジュール化
- 明確な責務分離
- 適切な抽象化
- 依存関係の最小化

### 6.2 コードレビュー
- プルリクエストの使用
- コードレビューの実施
- フィードバックの反映

## 7. ドキュメント

### 7.1 コードドキュメント
- 関数の目的と使用方法
- パラメータと戻り値の説明
- 使用例の提供

### 7.2 APIドキュメント
- 公開APIの完全なドキュメント
- 使用例とチュートリアル
- トラブルシューティングガイド

## 8. 継続的インテグレーション

### 8.1 自動テスト
- ユニットテストの自動実行
- 統合テストの自動実行
- テストカバレッジの監視

### 8.2 コード品質チェック
- リンターの実行
- フォーマッターの実行
- 静的解析の実施

## 9. バージョン管理

### 9.1 コミットメッセージ
- 明確な変更内容の説明
- 関連するIssue番号の参照
- 変更の種類の明示

### 9.2 ブランチ戦略
- 機能ブランチの使用
- リリースブランチの管理
- マージ戦略の定義

## 10. デプロイメント

### 10.1 ビルドプロセス
- 自動ビルドの設定
- 依存関係の管理
- ビルド成果物の管理

### 10.2 リリース管理
- バージョン番号の管理
- リリースノートの作成
- デプロイメントの自動化
